"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty2 = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty2(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _construct = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/construct"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _long = _interopRequireDefault(require("long"));

var _bgzfFilehandle = require("@gmod/bgzf-filehandle");

var _virtualOffset = require("./virtualOffset");

var _chunk = _interopRequireDefault(require("./chunk"));

var _util = require("./util");

var _indexFile = _interopRequireDefault(require("./indexFile"));

function ownKeys(object, enumerableOnly) { var keys = (0, _keys.default)(object); if (_getOwnPropertySymbols.default) { var symbols = (0, _getOwnPropertySymbols.default)(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return (0, _getOwnPropertyDescriptor.default)(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty3.default)(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors.default) { (0, _defineProperties.default)(target, (0, _getOwnPropertyDescriptors.default)(source)); } else { ownKeys(Object(source)).forEach(function (key) { (0, _defineProperty2.default)(target, key, (0, _getOwnPropertyDescriptor.default)(source, key)); }); } } return target; }

function _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = (0, _construct.default)(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_construct.default) return false; if (_construct.default.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call((0, _construct.default)(Date, [], function () {})); return true; } catch (e) { return false; } }

var CSI1_MAGIC = 21582659; // CSI\1

var CSI2_MAGIC = 38359875; // CSI\2

function lshift(num, bits) {
  return num * Math.pow(2, bits);
}

function rshift(num, bits) {
  return Math.floor(num / Math.pow(2, bits));
}

var CSI = /*#__PURE__*/function (_IndexFile) {
  (0, _inherits2.default)(CSI, _IndexFile);

  var _super = _createSuper(CSI);

  function CSI(args) {
    var _this;

    (0, _classCallCheck2.default)(this, CSI);
    _this = _super.call(this, args);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "maxBinNumber", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "depth", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "minShift", void 0);
    _this.maxBinNumber = 0;
    _this.depth = 0;
    _this.minShift = 0;
    return _this;
  }

  (0, _createClass2.default)(CSI, [{
    key: "lineCount",
    value: function () {
      var _lineCount = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(refName) {
        var opts,
            indexData,
            refId,
            idx,
            stats,
            _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return this.parse(opts);

              case 3:
                indexData = _context.sent;

                if (indexData) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", -1);

              case 6:
                refId = indexData.refNameToId[refName];
                idx = indexData.indices[refId];

                if (idx) {
                  _context.next = 10;
                  break;
                }

                return _context.abrupt("return", -1);

              case 10:
                stats = indexData.indices[refId].stats;

                if (!stats) {
                  _context.next = 13;
                  break;
                }

                return _context.abrupt("return", stats.lineCount);

              case 13:
                return _context.abrupt("return", -1);

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function lineCount(_x) {
        return _lineCount.apply(this, arguments);
      }

      return lineCount;
    }()
  }, {
    key: "indexCov",
    value: function () {
      var _indexCov = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                throw new Error('CSI indexes do not support indexcov');

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function indexCov() {
        return _indexCov.apply(this, arguments);
      }

      return indexCov;
    }()
  }, {
    key: "parseAuxData",
    value: function parseAuxData(bytes, offset, auxLength) {
      if (auxLength < 30) {
        return {
          refIdToName: [],
          refNameToId: {}
        };
      }

      var formatFlags = bytes.readInt32LE(offset);
      var coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';
      var format = {
        0: 'generic',
        1: 'SAM',
        2: 'VCF'
      }[formatFlags & 0xf];
      if (!format) throw new Error("invalid Tabix preset format flags ".concat(formatFlags));
      var columnNumbers = {
        ref: bytes.readInt32LE(offset + 4),
        start: bytes.readInt32LE(offset + 8),
        end: bytes.readInt32LE(offset + 12)
      };
      var metaValue = bytes.readInt32LE(offset + 16);
      var metaChar = metaValue ? String.fromCharCode(metaValue) : '';
      var skipLines = bytes.readInt32LE(offset + 20);
      var nameSectionLength = bytes.readInt32LE(offset + 24);

      var _this$_parseNameBytes = this._parseNameBytes(bytes.slice(offset + 28, offset + 28 + nameSectionLength)),
          refIdToName = _this$_parseNameBytes.refIdToName,
          refNameToId = _this$_parseNameBytes.refNameToId;

      return {
        refIdToName: refIdToName,
        refNameToId: refNameToId,
        skipLines: skipLines,
        metaChar: metaChar,
        columnNumbers: columnNumbers,
        format: format,
        coordinateType: coordinateType
      };
    }
  }, {
    key: "_parseNameBytes",
    value: function _parseNameBytes(namesBytes) {
      var currRefId = 0;
      var currNameStart = 0;
      var refIdToName = [];
      var refNameToId = {};

      for (var i = 0; i < namesBytes.length; i += 1) {
        if (!namesBytes[i]) {
          if (currNameStart < i) {
            var refName = namesBytes.toString('utf8', currNameStart, i);
            refName = this.renameRefSeq(refName);
            refIdToName[currRefId] = refName;
            refNameToId[refName] = currRefId;
          }

          currNameStart = i + 1;
          currRefId += 1;
        }
      }

      return {
        refNameToId: refNameToId,
        refIdToName: refIdToName
      };
    } // fetch and parse the index

  }, {
    key: "_parse",
    value: function () {
      var _parse2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        var _this2 = this;

        var opts,
            bytes,
            csiVersion,
            maxRefLength,
            auxLength,
            aux,
            refCount,
            firstDataLine,
            currOffset,
            indices,
            _args3 = arguments;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                _context3.t0 = _bgzfFilehandle.unzip;
                _context3.next = 4;
                return this.filehandle.readFile(opts);

              case 4:
                _context3.t1 = _context3.sent;
                _context3.next = 7;
                return (0, _context3.t0)(_context3.t1);

              case 7:
                bytes = _context3.sent;

                if (!(bytes.readUInt32LE(0) === CSI1_MAGIC)) {
                  _context3.next = 12;
                  break;
                }

                csiVersion = 1;
                _context3.next = 17;
                break;

              case 12:
                if (!(bytes.readUInt32LE(0) === CSI2_MAGIC)) {
                  _context3.next = 16;
                  break;
                }

                csiVersion = 2;
                _context3.next = 17;
                break;

              case 16:
                throw new Error('Not a CSI file');

              case 17:
                this.minShift = bytes.readInt32LE(4);
                this.depth = bytes.readInt32LE(8);
                this.maxBinNumber = ((1 << (this.depth + 1) * 3) - 1) / 7;
                maxRefLength = Math.pow(2, this.minShift + this.depth * 3);
                auxLength = bytes.readInt32LE(12);
                aux = {
                  refIdToName: [],
                  refNameToId: {}
                };

                if (auxLength) {
                  aux = this.parseAuxData(bytes, 16, auxLength);
                }

                refCount = bytes.readInt32LE(16 + auxLength); // read the indexes for each reference sequence

                currOffset = 16 + auxLength + 4;
                indices = new Array(refCount).fill(0).map(function () {
                  // the binning index
                  var binCount = bytes.readInt32LE(currOffset);
                  currOffset += 4;
                  var binIndex = {};
                  var stats; // < provided by parsing a pseudo-bin, if present

                  for (var j = 0; j < binCount; j += 1) {
                    var bin = bytes.readUInt32LE(currOffset);

                    if (bin > _this2.maxBinNumber) {
                      // this is a fake bin that actually has stats information
                      // about the reference sequence in it
                      stats = _this2.parsePseudoBin(bytes, currOffset + 4);
                      currOffset += 4 + 8 + 4 + 16 + 16;
                    } else {
                      var loffset = (0, _virtualOffset.fromBytes)(bytes, currOffset + 4);
                      firstDataLine = _this2._findFirstData(firstDataLine, loffset);
                      var chunkCount = bytes.readInt32LE(currOffset + 12);
                      currOffset += 16;
                      var chunks = new Array(chunkCount);

                      for (var k = 0; k < chunkCount; k += 1) {
                        var u = (0, _virtualOffset.fromBytes)(bytes, currOffset);
                        var v = (0, _virtualOffset.fromBytes)(bytes, currOffset + 8);
                        currOffset += 16; // this._findFirstData(data, u)

                        chunks[k] = new _chunk.default(u, v, bin);
                      }

                      binIndex[bin] = chunks;
                    }
                  }

                  return {
                    binIndex: binIndex,
                    stats: stats
                  };
                });
                return _context3.abrupt("return", _objectSpread({}, aux, {
                  csi: true,
                  refCount: refCount,
                  maxBlockSize: 1 << 16,
                  firstDataLine: firstDataLine,
                  csiVersion: csiVersion,
                  indices: indices,
                  depth: this.depth,
                  maxBinNumber: this.maxBinNumber,
                  maxRefLength: maxRefLength
                }));

              case 28:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _parse() {
        return _parse2.apply(this, arguments);
      }

      return _parse;
    }()
  }, {
    key: "parsePseudoBin",
    value: function parsePseudoBin(bytes, offset) {
      var lineCount = (0, _util.longToNumber)(_long.default.fromBytesLE(Array.prototype.slice.call(bytes, offset + 28, offset + 36), true));
      return {
        lineCount: lineCount
      };
    }
  }, {
    key: "blocksForRange",
    value: function () {
      var _blocksForRange = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(refName, beg, end) {
        var opts,
            indexData,
            refId,
            indexes,
            binIndex,
            bins,
            l,
            numOffsets,
            i,
            off,
            _i,
            chunks,
            j,
            _i2,
            _i3,
            _i4,
            _args4 = arguments;

        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                opts = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : {};
                if (beg < 0) beg = 0;
                _context4.next = 4;
                return this.parse(opts);

              case 4:
                indexData = _context4.sent;

                if (indexData) {
                  _context4.next = 7;
                  break;
                }

                return _context4.abrupt("return", []);

              case 7:
                refId = indexData.refNameToId[refName];
                indexes = indexData.indices[refId];

                if (indexes) {
                  _context4.next = 11;
                  break;
                }

                return _context4.abrupt("return", []);

              case 11:
                binIndex = indexes.binIndex;
                bins = this.reg2bins(beg, end);
                numOffsets = 0;

                for (i = 0; i < bins.length; i += 1) {
                  if (binIndex[bins[i]]) numOffsets += binIndex[bins[i]].length;
                }

                if (!(numOffsets === 0)) {
                  _context4.next = 17;
                  break;
                }

                return _context4.abrupt("return", []);

              case 17:
                off = [];
                numOffsets = 0;

                for (_i = 0; _i < bins.length; _i += 1) {
                  chunks = binIndex[bins[_i]];
                  if (chunks) for (j = 0; j < chunks.length; j += 1) {
                    off[numOffsets] = new _chunk.default(chunks[j].minv, chunks[j].maxv, chunks[j].bin);
                    numOffsets += 1;
                  }
                }

                if (off.length) {
                  _context4.next = 22;
                  break;
                }

                return _context4.abrupt("return", []);

              case 22:
                off = off.sort(function (a, b) {
                  return a.compareTo(b);
                }); // resolve completely contained adjacent blocks

                l = 0;

                for (_i2 = 1; _i2 < numOffsets; _i2 += 1) {
                  if (off[l].maxv.compareTo(off[_i2].maxv) < 0) {
                    l += 1;
                    off[l].minv = off[_i2].minv;
                    off[l].maxv = off[_i2].maxv;
                  }
                }

                numOffsets = l + 1; // resolve overlaps between adjacent blocks; this may happen due to the merge in indexing

                for (_i3 = 1; _i3 < numOffsets; _i3 += 1) {
                  if (off[_i3 - 1].maxv.compareTo(off[_i3].minv) >= 0) {
                    off[_i3 - 1].maxv = off[_i3].minv;
                  }
                } // merge adjacent blocks


                l = 0;

                for (_i4 = 1; _i4 < numOffsets; _i4 += 1) {
                  if (off[l].maxv.blockPosition === off[_i4].minv.blockPosition) off[l].maxv = off[_i4].maxv;else {
                    l += 1;
                    off[l].minv = off[_i4].minv;
                    off[l].maxv = off[_i4].maxv;
                  }
                }

                numOffsets = l + 1;
                return _context4.abrupt("return", off.slice(0, numOffsets));

              case 31:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function blocksForRange(_x2, _x3, _x4) {
        return _blocksForRange.apply(this, arguments);
      }

      return blocksForRange;
    }()
    /**
     * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)
     * @returns {Array[number]}
     */

  }, {
    key: "reg2bins",
    value: function reg2bins(beg, end) {
      beg -= 1; // < convert to 1-based closed

      if (beg < 1) beg = 1;
      if (end > Math.pow(2, 50)) end = Math.pow(2, 34); // 17 GiB ought to be enough for anybody

      end -= 1;
      var l = 0;
      var t = 0;
      var s = this.minShift + this.depth * 3;
      var bins = [];

      for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {
        var b = t + rshift(beg, s);
        var e = t + rshift(end, s);
        if (e - b + bins.length > this.maxBinNumber) throw new Error("query ".concat(beg, "-").concat(end, " is too large for current binning scheme (shift ").concat(this.minShift, ", depth ").concat(this.depth, "), try a smaller query or a coarser index binning scheme"));

        for (var i = b; i <= e; i += 1) {
          bins.push(i);
        }
      }

      return bins;
    }
  }]);
  return CSI;
}(_indexFile.default);

exports.default = CSI;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jc2kudHMiXSwibmFtZXMiOlsiQ1NJMV9NQUdJQyIsIkNTSTJfTUFHSUMiLCJsc2hpZnQiLCJudW0iLCJiaXRzIiwicnNoaWZ0IiwiTWF0aCIsImZsb29yIiwiQ1NJIiwiYXJncyIsIm1heEJpbk51bWJlciIsImRlcHRoIiwibWluU2hpZnQiLCJyZWZOYW1lIiwib3B0cyIsInBhcnNlIiwiaW5kZXhEYXRhIiwicmVmSWQiLCJyZWZOYW1lVG9JZCIsImlkeCIsImluZGljZXMiLCJzdGF0cyIsImxpbmVDb3VudCIsIkVycm9yIiwiYnl0ZXMiLCJvZmZzZXQiLCJhdXhMZW5ndGgiLCJyZWZJZFRvTmFtZSIsImZvcm1hdEZsYWdzIiwicmVhZEludDMyTEUiLCJjb29yZGluYXRlVHlwZSIsImZvcm1hdCIsImNvbHVtbk51bWJlcnMiLCJyZWYiLCJzdGFydCIsImVuZCIsIm1ldGFWYWx1ZSIsIm1ldGFDaGFyIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwic2tpcExpbmVzIiwibmFtZVNlY3Rpb25MZW5ndGgiLCJfcGFyc2VOYW1lQnl0ZXMiLCJzbGljZSIsIm5hbWVzQnl0ZXMiLCJjdXJyUmVmSWQiLCJjdXJyTmFtZVN0YXJ0IiwiaSIsImxlbmd0aCIsInRvU3RyaW5nIiwicmVuYW1lUmVmU2VxIiwidW56aXAiLCJmaWxlaGFuZGxlIiwicmVhZEZpbGUiLCJyZWFkVUludDMyTEUiLCJjc2lWZXJzaW9uIiwibWF4UmVmTGVuZ3RoIiwiYXV4IiwicGFyc2VBdXhEYXRhIiwicmVmQ291bnQiLCJjdXJyT2Zmc2V0IiwiQXJyYXkiLCJmaWxsIiwibWFwIiwiYmluQ291bnQiLCJiaW5JbmRleCIsImoiLCJiaW4iLCJwYXJzZVBzZXVkb0JpbiIsImxvZmZzZXQiLCJmaXJzdERhdGFMaW5lIiwiX2ZpbmRGaXJzdERhdGEiLCJjaHVua0NvdW50IiwiY2h1bmtzIiwiayIsInUiLCJ2IiwiQ2h1bmsiLCJjc2kiLCJtYXhCbG9ja1NpemUiLCJMb25nIiwiZnJvbUJ5dGVzTEUiLCJwcm90b3R5cGUiLCJjYWxsIiwiYmVnIiwiaW5kZXhlcyIsImJpbnMiLCJyZWcyYmlucyIsIm51bU9mZnNldHMiLCJvZmYiLCJtaW52IiwibWF4diIsInNvcnQiLCJhIiwiYiIsImNvbXBhcmVUbyIsImwiLCJibG9ja1Bvc2l0aW9uIiwidCIsInMiLCJlIiwicHVzaCIsIkluZGV4RmlsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7OztBQUVBLElBQU1BLFVBQVUsR0FBRyxRQUFuQixDLENBQTRCOztBQUM1QixJQUFNQyxVQUFVLEdBQUcsUUFBbkIsQyxDQUE0Qjs7QUFFNUIsU0FBU0MsTUFBVCxDQUFnQkMsR0FBaEIsRUFBNkJDLElBQTdCLEVBQTJDO0FBQ3pDLFNBQU9ELEdBQUcsWUFBRyxDQUFILEVBQVFDLElBQVIsQ0FBVjtBQUNEOztBQUNELFNBQVNDLE1BQVQsQ0FBZ0JGLEdBQWhCLEVBQTZCQyxJQUE3QixFQUEyQztBQUN6QyxTQUFPRSxJQUFJLENBQUNDLEtBQUwsQ0FBV0osR0FBRyxZQUFHLENBQUgsRUFBUUMsSUFBUixDQUFkLENBQVA7QUFDRDs7SUFFb0JJLEc7Ozs7O0FBSW5CLGVBQVlDLElBQVosRUFBdUI7QUFBQTs7QUFBQTtBQUNyQiw4QkFBTUEsSUFBTjtBQURxQjtBQUFBO0FBQUE7QUFFckIsVUFBS0MsWUFBTCxHQUFvQixDQUFwQjtBQUNBLFVBQUtDLEtBQUwsR0FBYSxDQUFiO0FBQ0EsVUFBS0MsUUFBTCxHQUFnQixDQUFoQjtBQUpxQjtBQUt0Qjs7Ozs7Z0hBQ2VDLE87Ozs7Ozs7Ozs7O0FBQWlCQyxnQkFBQUEsSSwyREFBZ0IsRTs7dUJBQ3ZCLEtBQUtDLEtBQUwsQ0FBV0QsSUFBWCxDOzs7QUFBbEJFLGdCQUFBQSxTOztvQkFDREEsUzs7Ozs7aURBQWtCLENBQUMsQzs7O0FBQ2xCQyxnQkFBQUEsSyxHQUFRRCxTQUFTLENB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ckQsQ0FBQyxJQUFJLENBQTdCO0FBQWdDdUMsVUFBQUEsSUFBSSxDQUFDZSxJQUFMLENBQVV0RCxDQUFWO0FBQWhDO0FBQ0Q7O0FBQ0QsYUFBT3VDLElBQVA7QUFDRDs7O0VBMVI4QmdCLGtCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExvbmcgZnJvbSAnbG9uZydcbmltcG9ydCB7IHVuemlwIH0gZnJvbSAnQGdtb2QvYmd6Zi1maWxlaGFuZGxlJ1xuXG5pbXBvcnQgVmlydHVhbE9mZnNldCwgeyBmcm9tQnl0ZXMgfSBmcm9tICcuL3ZpcnR1YWxPZmZzZXQnXG5pbXBvcnQgQ2h1bmsgZnJvbSAnLi9jaHVuaydcbmltcG9ydCB7IGxvbmdUb051bWJlciB9IGZyb20gJy4vdXRpbCdcblxuaW1wb3J0IEluZGV4RmlsZSwgeyBPcHRpb25zIH0gZnJvbSAnLi9pbmRleEZpbGUnXG5cbmNvbnN0IENTSTFfTUFHSUMgPSAyMTU4MjY1OSAvLyBDU0lcXDFcbmNvbnN0IENTSTJfTUFHSUMgPSAzODM1OTg3NSAvLyBDU0lcXDJcblxuZnVuY3Rpb24gbHNoaWZ0KG51bTogbnVtYmVyLCBiaXRzOiBudW1iZXIpIHtcbiAgcmV0dXJuIG51bSAqIDIgKiogYml0c1xufVxuZnVuY3Rpb24gcnNoaWZ0KG51bTogbnVtYmVyLCBiaXRzOiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IobnVtIC8gMiAqKiBiaXRzKVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDU0kgZXh0ZW5kcyBJbmRleEZpbGUge1xuICBwcml2YXRlIG1heEJpbk51bWJlcjogbnVtYmVyXG4gIHByaXZhdGUgZGVwdGg6IG51bWJlclxuICBwcml2YXRlIG1pblNoaWZ0OiBudW1iZXJcbiAgY29uc3RydWN0b3IoYXJnczogYW55KSB7XG4gICAgc3VwZXIoYXJncylcbiAgICB0aGlzLm1heEJpbk51bWJlciA9IDBcbiAgICB0aGlzLmRlcHRoID0gMFxuICAgIHRoaXMubWluU2hpZnQgPSAwXG4gIH1cbiAgYXN5bmMgbGluZUNvdW50KHJlZk5hbWU6IHN0cmluZywgb3B0czogT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpXG4gICAgaWYgKCFpbmRleERhdGEpIHJldHVybiAtMVxuICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdXG4gICAgY29uc3QgaWR4ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdXG4gICAgaWYgKCFpZHgpIHJldHVybiAtMVxuICAgIGNvbnN0IHsgc3RhdHMgfSA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXVxuICAgIGlmIChzdGF0cykgcmV0dXJuIHN0YXRzLmxpbmVDb3VudFxuICAgIHJldHVybiAtMVxuICB9XG4gIGFzeW5jIGluZGV4Q292KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ1NJIGluZGV4ZXMgZG8gbm90IHN1cHBvcnQgaW5kZXhjb3YnKVxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcGFyc2VBdXhEYXRhKGJ5dGVzOiBCdWZmZXIsIG9mZnNldDogbnVtYmVyLCBhdXhMZW5ndGg6IG51bWJlcikge1xuICAgIGlmIChhdXhMZW5ndGggPCAzMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVmSWRUb05hbWU6IFtdLFxuICAgICAgICByZWZOYW1lVG9JZDoge30sXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybWF0RmxhZ3MgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQpXG4gICAgY29uc3QgY29vcmRpbmF0ZVR5cGUgPVxuICAgICAgZm9ybWF0RmxhZ3MgJiAweDEwMDAwID8gJ3plcm8tYmFzZWQtaGFsZi1vcGVuJyA6ICcxLWJhc2VkLWNsb3NlZCdcbiAgICBjb25zdCBmb3JtYXQgPSAoeyAwOiAnZ2VuZXJpYycsIDE6ICdTQU0nLCAyOiAnVkNGJyB9IGFzIHtcbiAgICAgIFtrZXk6IG51bWJlcl06IHN0cmluZ1xuICAgIH0pW2Zvcm1hdEZsYWdzICYgMHhmXVxuICAgIGlmICghZm9ybWF0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIFRhYml4IHByZXNldCBmb3JtYXQgZmxhZ3MgJHtmb3JtYXRGbGFnc31gKVxuICAgIGNvbnN0IGNvbHVtbk51bWJlcnMgPSB7XG4gICAgICByZWY6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDQpLFxuICAgICAgc3RhcnQ6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDgpLFxuICAgICAgZW5kOiBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAxMiksXG4gICAgfVxuICAgIGNvbnN0IG1ldGFWYWx1ZSA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDE2KVxuICAgIGNvbnN0IG1ldGFDaGFyID0gbWV0YVZhbHVlID8gU3RyaW5nLmZyb21DaGFyQ29kZShtZXRhVmFsdWUpIDogJydcbiAgICBjb25zdCBza2lwTGluZXMgPSBieXRlcy5yZWFkSW50MzJMRShvZmZzZXQgKyAyMClcbiAgICBjb25zdCBuYW1lU2VjdGlvbkxlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDI0KVxuXG4gICAgY29uc3QgeyByZWZJZFRvTmFtZSwgcmVmTmFtZVRvSWQgfSA9IHRoaXMuX3BhcnNlTmFtZUJ5dGVzKFxuICAgICAgYnl0ZXMuc2xpY2Uob2Zmc2V0ICsgMjgsIG9mZnNldCArIDI4ICsgbmFtZVNlY3Rpb25MZW5ndGgpLFxuICAgIClcblxuICAgIHJldHVybiB7XG4gICAgICByZWZJZFRvTmFtZSxcbiAgICAgIHJlZk5hbWVUb0lkLFxuICAgICAgc2tpcExpbmVzLFxuICAgICAgbWV0YUNoYXIsXG4gICAgICBjb2x1bW5OdW1iZXJzLFxuICAgICAgZm9ybWF0LFxuICAgICAgY29vcmRpbmF0ZVR5cGUsXG4gICAgfVxuICB9XG5cbiAgX3BhcnNlTmFtZUJ5dGVzKG5hbWVzQnl0ZXM6IEJ1ZmZlcikge1xuICAgIGxldCBjdXJyUmVmSWQgPSAwXG4gICAgbGV0IGN1cnJOYW1lU3RhcnQgPSAwXG4gICAgY29uc3QgcmVmSWRUb05hbWUgPSBbXVxuICAgIGNvbnN0IHJlZk5hbWVUb0lkOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge31cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzQnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICghbmFtZXNCeXRlc1tpXSkge1xuICAgICAgICBpZiAoY3Vyck5hbWVTdGFydCA8IGkpIHtcbiAgICAgICAgICBsZXQgcmVmTmFtZSA9IG5hbWVzQnl0ZXMudG9TdHJpbmcoJ3V0ZjgnLCBjdXJyTmFtZVN0YXJ0LCBpKVxuICAgICAgICAgIHJlZk5hbWUgPSB0aGlzLnJlbmFtZVJlZlNlcShyZWZOYW1lKVxuICAgICAgICAgIHJlZklkVG9OYW1lW2N1cnJSZWZJZF0gPSByZWZOYW1lXG4gICAgICAgICAgcmVmTmFtZVRvSWRbcmVmTmFtZV0gPSBjdXJyUmVmSWRcbiAgICAgICAgfVxuICAgICAgICBjdXJyTmFtZVN0YXJ0ID0gaSArIDFcbiAgICAgICAgY3VyclJlZklkICs9IDFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH1cbiAgfVxuXG4gIC8vIGZldGNoIGFuZCBwYXJzZSB0aGUgaW5kZXhcblxuICBhc3luYyBfcGFyc2Uob3B0czogT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB1bnppcCgoYXdhaXQgdGhpcy5maWxlaGFuZGxlLnJlYWRGaWxlKG9wdHMpKSBhcyBCdWZmZXIpXG5cbiAgICAvLyBjaGVjayBUQkkgbWFnaWMgbnVtYmVyc1xuICAgIGxldCBjc2lWZXJzaW9uXG4gICAgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSA9PT0gQ1NJMV9NQUdJQykge1xuICAgICAgY3NpVmVyc2lvbiA9IDFcbiAgICB9IGVsc2UgaWYgKGJ5dGVzLnJlYWRVSW50MzJMRSgwKSA9PT0gQ1NJMl9NQUdJQykge1xuICAgICAgY3NpVmVyc2lvbiA9IDJcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBDU0kgZmlsZScpXG4gICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRvIHN1cHBvcnQgYmlnLWVuZGlhbiBDU0kgZmlsZXM/XG4gICAgfVxuXG4gICAgdGhpcy5taW5TaGlmdCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDQpXG4gICAgdGhpcy5kZXB0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDgpXG4gICAgdGhpcy5tYXhCaW5OdW1iZXIgPSAoKDEgPDwgKCh0aGlzLmRlcHRoICsgMSkgKiAzKSkgLSAxKSAvIDdcbiAgICBjb25zdCBtYXhSZWZMZW5ndGggPSAyICoqICh0aGlzLm1pblNoaWZ0ICsgdGhpcy5kZXB0aCAqIDMpXG5cbiAgICBjb25zdCBhdXhMZW5ndGggPSBieXRlcy5yZWFkSW50MzJMRSgxMilcbiAgICBsZXQgYXV4OiB7XG4gICAgICByZWZJZFRvTmFtZTogc3RyaW5nW11cbiAgICAgIHJlZk5hbWVUb0lkOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9XG4gICAgfSA9IHtcbiAgICAgIHJlZklkVG9OYW1lOiBbXSxcbiAgICAgIHJlZk5hbWVUb0lkOiB7fSxcbiAgICB9XG4gICAgaWYgKGF1eExlbmd0aCkge1xuICAgICAgYXV4ID0gdGhpcy5wYXJzZUF1eERhdGEoYnl0ZXMsIDE2LCBhdXhMZW5ndGgpXG4gICAgfVxuICAgIGNvbnN0IHJlZkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoMTYgKyBhdXhMZW5ndGgpXG5cbiAgICAvLyByZWFkIHRoZSBpbmRleGVzIGZvciBlYWNoIHJlZmVyZW5jZSBzZXF1ZW5jZVxuICAgIGxldCBmaXJzdERhdGFMaW5lOiBWaXJ0dWFsT2Zmc2V0IHwgdW5kZWZpbmVkXG4gICAgbGV0IGN1cnJPZmZzZXQgPSAxNiArIGF1eExlbmd0aCArIDRcbiAgICBjb25zdCBpbmRpY2VzID0gbmV3IEFycmF5KHJlZkNvdW50KS5maWxsKDApLm1hcCgoKSA9PiB7XG4gICAgICAvLyB0aGUgYmlubmluZyBpbmRleFxuICAgICAgY29uc3QgYmluQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KVxuICAgICAgY3Vyck9mZnNldCArPSA0XG4gICAgICBjb25zdCBiaW5JbmRleDogeyBba2V5OiBzdHJpbmddOiBDaHVua1tdIH0gPSB7fVxuICAgICAgbGV0IHN0YXRzIC8vIDwgcHJvdmlkZWQgYnkgcGFyc2luZyBhIHBzZXVkby1iaW4sIGlmIHByZXNlbnRcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmluQ291bnQ7IGogKz0gMSkge1xuICAgICAgICBjb25zdCBiaW4gPSBieXRlcy5yZWFkVUludDMyTEUoY3Vyck9mZnNldClcbiAgICAgICAgaWYgKGJpbiA+IHRoaXMubWF4QmluTnVtYmVyKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhIGZha2UgYmluIHRoYXQgYWN0dWFsbHkgaGFzIHN0YXRzIGluZm9ybWF0aW9uXG4gICAgICAgICAgLy8gYWJvdXQgdGhlIHJlZmVyZW5jZSBzZXF1ZW5jZSBpbiBpdFxuICAgICAgICAgIHN0YXRzID0gdGhpcy5wYXJzZVBzZXVkb0JpbihieXRlcywgY3Vyck9mZnNldCArIDQpXG4gICAgICAgICAgY3Vyck9mZnNldCArPSA0ICsgOCArIDQgKyAxNiArIDE2XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbG9mZnNldCA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldCArIDQpXG4gICAgICAgICAgZmlyc3REYXRhTGluZSA9IHRoaXMuX2ZpbmRGaXJzdERhdGEoZmlyc3REYXRhTGluZSwgbG9mZnNldClcbiAgICAgICAgICBjb25zdCBjaHVua0NvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldCArIDEyKVxuICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTZcbiAgICAgICAgICBjb25zdCBjaHVua3MgPSBuZXcgQXJyYXkoY2h1bmtDb3VudClcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNodW5rQ291bnQ7IGsgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgdSA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldClcbiAgICAgICAgICAgIGNvbnN0IHYgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQgKyA4KVxuICAgICAgICAgICAgY3Vyck9mZnNldCArPSAxNlxuICAgICAgICAgICAgLy8gdGhpcy5fZmluZEZpcnN0RGF0YShkYXRhLCB1KVxuICAgICAgICAgICAgY2h1bmtzW2tdID0gbmV3IENodW5rKHUsIHYsIGJpbilcbiAgICAgICAgICB9XG4gICAgICAgICAgYmluSW5kZXhbYmluXSA9IGNodW5rc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGJpbkluZGV4LCBzdGF0cyB9XG4gICAgfSlcblxuICAgIHJldHVybiB7XG4gICAgICAuLi5hdXgsXG4gICAgICBjc2k6IHRydWUsXG4gICAgICByZWZDb3VudCxcbiAgICAgIG1heEJsb2NrU2l6ZTogMSA8PCAxNixcbiAgICAgIGZpcnN0RGF0YUxpbmUsXG4gICAgICBjc2lWZXJzaW9uLFxuICAgICAgaW5kaWNlcyxcbiAgICAgIGRlcHRoOiB0aGlzLmRlcHRoLFxuICAgICAgbWF4QmluTnVtYmVyOiB0aGlzLm1heEJpbk51bWJlcixcbiAgICAgIG1heFJlZkxlbmd0aCxcbiAgICB9XG4gIH1cblxuICBwYXJzZVBzZXVkb0JpbihieXRlczogQnVmZmVyLCBvZmZzZXQ6IG51bWJlcikge1xuICAgIGNvbnN0IGxpbmVDb3VudCA9IGxvbmdUb051bWJlcihcbiAgICAgIExvbmcuZnJvbUJ5dGVzTEUoXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzLCBvZmZzZXQgKyAyOCwgb2Zmc2V0ICsgMzYpLFxuICAgICAgICB0cnVlLFxuICAgICAgKSxcbiAgICApXG4gICAgcmV0dXJuIHsgbGluZUNvdW50IH1cbiAgfVxuXG4gIGFzeW5jIGJsb2Nrc0ZvclJhbmdlKFxuICAgIHJlZk5hbWU6IHN0cmluZyxcbiAgICBiZWc6IG51bWJlcixcbiAgICBlbmQ6IG51bWJlcixcbiAgICBvcHRzOiBPcHRpb25zID0ge30sXG4gICkge1xuICAgIGlmIChiZWcgPCAwKSBiZWcgPSAwXG5cbiAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpXG4gICAgaWYgKCFpbmRleERhdGEpIHJldHVybiBbXVxuICAgIGNvbnN0IHJlZklkID0gaW5kZXhEYXRhLnJlZk5hbWVUb0lkW3JlZk5hbWVdXG4gICAgY29uc3QgaW5kZXhlcyA9IGluZGV4RGF0YS5pbmRpY2VzW3JlZklkXVxuICAgIGlmICghaW5kZXhlcykgcmV0dXJuIFtdXG5cbiAgICBjb25zdCB7IGJpbkluZGV4IH0gPSBpbmRleGVzXG5cbiAgICBjb25zdCBiaW5zID0gdGhpcy5yZWcyYmlucyhiZWcsIGVuZClcblxuICAgIGxldCBsXG4gICAgbGV0IG51bU9mZnNldHMgPSAwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoYmluSW5kZXhbYmluc1tpXV0pIG51bU9mZnNldHMgKz0gYmluSW5kZXhbYmluc1tpXV0ubGVuZ3RoXG4gICAgfVxuXG4gICAgaWYgKG51bU9mZnNldHMgPT09IDApIHJldHVybiBbXVxuXG4gICAgbGV0IG9mZiA9IFtdXG4gICAgbnVtT2Zmc2V0cyA9IDBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGNodW5rcyA9IGJpbkluZGV4W2JpbnNbaV1dXG4gICAgICBpZiAoY2h1bmtzKVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNodW5rcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIG9mZltudW1PZmZzZXRzXSA9IG5ldyBDaHVuayhcbiAgICAgICAgICAgIGNodW5rc1tqXS5taW52LFxuICAgICAgICAgICAgY2h1bmtzW2pdLm1heHYsXG4gICAgICAgICAgICBjaHVua3Nbal0uYmluLFxuICAgICAgICAgIClcbiAgICAgICAgICBudW1PZmZzZXRzICs9IDFcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghb2ZmLmxlbmd0aCkgcmV0dXJuIFtdXG5cbiAgICBvZmYgPSBvZmYuc29ydCgoYSwgYikgPT4gYS5jb21wYXJlVG8oYikpXG5cbiAgICAvLyByZXNvbHZlIGNvbXBsZXRlbHkgY29udGFpbmVkIGFkamFjZW50IGJsb2Nrc1xuICAgIGwgPSAwXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1PZmZzZXRzOyBpICs9IDEpIHtcbiAgICAgIGlmIChvZmZbbF0ubWF4di5jb21wYXJlVG8ob2ZmW2ldLm1heHYpIDwgMCkge1xuICAgICAgICBsICs9IDFcbiAgICAgICAgb2ZmW2xdLm1pbnYgPSBvZmZbaV0ubWludlxuICAgICAgICBvZmZbbF0ubWF4diA9IG9mZltpXS5tYXh2XG4gICAgICB9XG4gICAgfVxuICAgIG51bU9mZnNldHMgPSBsICsgMVxuXG4gICAgLy8gcmVzb2x2ZSBvdmVybGFwcyBiZXR3ZWVuIGFkamFjZW50IGJsb2NrczsgdGhpcyBtYXkgaGFwcGVuIGR1ZSB0byB0aGUgbWVyZ2UgaW4gaW5kZXhpbmdcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bU9mZnNldHM7IGkgKz0gMSkge1xuICAgICAgaWYgKG9mZltpIC0gMV0ubWF4di5jb21wYXJlVG8ob2ZmW2ldLm1pbnYpID49IDApIHtcbiAgICAgICAgb2ZmW2kgLSAxXS5tYXh2ID0gb2ZmW2ldLm1pbnZcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtZXJnZSBhZGphY2VudCBibG9ja3NcbiAgICBsID0gMFxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtT2Zmc2V0czsgaSArPSAxKSB7XG4gICAgICBpZiAob2ZmW2xdLm1heHYuYmxvY2tQb3NpdGlvbiA9PT0gb2ZmW2ldLm1pbnYuYmxvY2tQb3NpdGlvbilcbiAgICAgICAgb2ZmW2xdLm1heHYgPSBvZmZbaV0ubWF4dlxuICAgICAgZWxzZSB7XG4gICAgICAgIGwgKz0gMVxuICAgICAgICBvZmZbbF0ubWludiA9IG9mZltpXS5taW52XG4gICAgICAgIG9mZltsXS5tYXh2ID0gb2ZmW2ldLm1heHZcbiAgICAgIH1cbiAgICB9XG4gICAgbnVtT2Zmc2V0cyA9IGwgKyAxXG5cbiAgICByZXR1cm4gb2ZmLnNsaWNlKDAsIG51bU9mZnNldHMpXG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBsaXN0IG9mIGJpbnMgdGhhdCBtYXkgb3ZlcmxhcCB3aXRoIHJlZ2lvbiBbYmVnLGVuZCkgKHplcm8tYmFzZWQgaGFsZi1vcGVuKVxuICAgKiBAcmV0dXJucyB7QXJyYXlbbnVtYmVyXX1cbiAgICovXG4gIHJlZzJiaW5zKGJlZzogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgIGJlZyAtPSAxIC8vIDwgY29udmVydCB0byAxLWJhc2VkIGNsb3NlZFxuICAgIGlmIChiZWcgPCAxKSBiZWcgPSAxXG4gICAgaWYgKGVuZCA+IDIgKiogNTApIGVuZCA9IDIgKiogMzQgLy8gMTcgR2lCIG91Z2h0IHRvIGJlIGVub3VnaCBmb3IgYW55Ym9keVxuICAgIGVuZCAtPSAxXG4gICAgbGV0IGwgPSAwXG4gICAgbGV0IHQgPSAwXG4gICAgbGV0IHMgPSB0aGlzLm1pblNoaWZ0ICsgdGhpcy5kZXB0aCAqIDNcbiAgICBjb25zdCBiaW5zID0gW11cbiAgICBmb3IgKDsgbCA8PSB0aGlzLmRlcHRoOyBzIC09IDMsIHQgKz0gbHNoaWZ0KDEsIGwgKiAzKSwgbCArPSAxKSB7XG4gICAgICBjb25zdCBiID0gdCArIHJzaGlmdChiZWcsIHMpXG4gICAgICBjb25zdCBlID0gdCArIHJzaGlmdChlbmQsIHMpXG4gICAgICBpZiAoZSAtIGIgKyBiaW5zLmxlbmd0aCA+IHRoaXMubWF4QmluTnVtYmVyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYHF1ZXJ5ICR7YmVnfS0ke2VuZH0gaXMgdG9vIGxhcmdlIGZvciBjdXJyZW50IGJpbm5pbmcgc2NoZW1lIChzaGlmdCAke3RoaXMubWluU2hpZnR9LCBkZXB0aCAke3RoaXMuZGVwdGh9KSwgdHJ5IGEgc21hbGxlciBxdWVyeSBvciBhIGNvYXJzZXIgaW5kZXggYmlubmluZyBzY2hlbWVgLFxuICAgICAgICApXG4gICAgICBmb3IgKGxldCBpID0gYjsgaSA8PSBlOyBpICs9IDEpIGJpbnMucHVzaChpKVxuICAgIH1cbiAgICByZXR1cm4gYmluc1xuICB9XG59XG4iXX0=