"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
//TODO: Remove this with proper fix
var headersx;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _fileUriToPath = _interopRequireDefault(require("file-uri-to-path"));

var _ = require(".");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var myGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {
  fetch: undefined
};

var RemoteFile = /*#__PURE__*/function () {
  (0, _createClass2.default)(RemoteFile, [{
    key: "getBufferFromResponse",
    value: function () {
      var _getBufferFromResponse = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(response) {
        var resp;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(typeof response.buffer === 'function')) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", response.buffer());

              case 4:
                if (!(typeof response.arrayBuffer === 'function')) {
                  _context.next = 11;
                  break;
                }

                _context.next = 7;
                return response.arrayBuffer();

              case 7:
                resp = _context.sent;
                return _context.abrupt("return", Buffer.from(resp));

              case 11:
                throw new TypeError('invalid HTTP response object, has no buffer method, and no arrayBuffer method');

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function getBufferFromResponse(_x) {
        return _getBufferFromResponse.apply(this, arguments);
      }

      return getBufferFromResponse;
    }()
  }]);

  function RemoteFile(source) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, RemoteFile);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "_stat", void 0);
    (0, _defineProperty2.default)(this, "fetch", void 0);
    (0, _defineProperty2.default)(this, "baseOverrides", {});
    this.url = source; // if it is a file URL, monkey-patch ourselves to act like a LocalFile

    if (source.startsWith('file://')) {
      var path = (0, _fileUriToPath.default)(source);
      if (!path) throw new TypeError('invalid file url');
      var localFile = new _.LocalFile(path);
      this.read = localFile.read.bind(localFile);
      this.readFile = localFile.readFile.bind(localFile);
      this.stat = localFile.stat.bind(localFile); // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
      // @ts-ignore

      this.fetch = function () {
        /* intentionally blank */
      };

      return;
    }

    var fetch = opts.fetch || myGlobal.fetch && myGlobal.fetch.bind(myGlobal);
    //TODO: Remove this with proper fix
    headersx = opts.headers
    if (!fetch) {
      throw new TypeError("no fetch function supplied, and none found in global environment");
    }

    if (opts.overrides) {
      this.baseOverrides = opts.overrides;
    }

    this.fetch = fetch;
  }

  (0, _createClass2.default)(RemoteFile, [{
    key: "read",
    value: function () {
      var _read = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(buffer) {
        var offset,
            length,
            position,
            opts,
            _opts$headers,
            headers,
            signal,
            _opts$overrides,
            overrides,
            response,
            responseData,
            bytesCopied,
            res,
            sizeMatch,
            _args2 = arguments;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                offset = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0;
                length = _args2.length > 2 ? _args2[2] : undefined;
                position = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 0;
                opts = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : {};
                //TODO: Remove this with proper fizx
                opts.headers = headersx
                _opts$headers = opts.headers, headers = _opts$headers === void 0 ? {} : _opts$headers, signal = opts.signal, _opts$overrides = opts.overrides, overrides = _opts$overrides === void 0 ? {} : _opts$overrides;

                if (length < Infinity) {
                  headers.range = "bytes=".concat(position, "-").concat(position + length);
                } else if (length === Infinity && position !== 0) {
                  headers.range = "bytes=".concat(position, "-");
                }

                _context2.next = 8;
                return this.fetch(this.url, _objectSpread(_objectSpread(_objectSpread({}, this.baseOverrides), overrides), {}, {
                  headers: _objectSpread(_objectSpread(_objectSpread({}, headers), overrides.headers), this.baseOverrides.headers),
                  method: 'GET',
                  redirect: 'follow',
                  mode: 'cors',
                  signal: signal
                }));

              case 8:
                response = _context2.sent;

                if (!(response.status === 200 && position === 0 || response.status === 206)) {
                  _context2.next = 18;
                  break;
                }

                _context2.next = 12;
                return this.getBufferFromResponse(response);

              case 12:
                responseData = _context2.sent;
                bytesCopied = responseData.copy(buffer, offset, 0, Math.min(length, responseData.length)); // try to parse out the size of the remote file

                res = response.headers.get('content-range');
                sizeMatch = /\/(\d+)$/.exec(res || '');
                if (sizeMatch && sizeMatch[1]) this._stat = {
                  size: parseInt(sizeMatch[1], 10)
                };
                return _context2.abrupt("return", {
                  bytesRead: bytesCopied,
                  buffer: buffer
                });

              case 18:
                throw new Error("HTTP ".concat(response.status, " fetching ").concat(this.url));

              case 19:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function read(_x2) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "readFile",
    value: function () {
      var _readFile = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        var options,
            encoding,
            opts,
            _opts,
            _opts$headers2,
            headers,
            signal,
            _opts$overrides2,
            overrides,
            response,
            _args3 = arguments;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};

                if (typeof options === 'string') {
                  encoding = options;
                  opts = {};
                } else {
                  encoding = options.encoding;
                  opts = options;
                  delete opts.encoding;
                }

                _opts = opts, _opts$headers2 = _opts.headers, headers = _opts$headers2 === void 0 ? {} : _opts$headers2, signal = _opts.signal, _opts$overrides2 = _opts.overrides, overrides = _opts$overrides2 === void 0 ? {} : _opts$overrides2;
                //TODO: remove this with proper fix
                headers = headersx
                _context3.next = 5;
                return this.fetch(this.url, _objectSpread(_objectSpread({
                  headers: headers,
                  method: 'GET',
                  redirect: 'follow',
                  mode: 'cors',
                  signal: signal
                }, this.baseOverrides), overrides));

              case 5:
                response = _context3.sent;

                if (!(response.status !== 200)) {
                  _context3.next = 8;
                  break;
                }

                throw Object.assign(new Error("HTTP ".concat(response.status, " fetching ").concat(this.url)), {
                  status: response.status
                });

              case 8:
                if (!(encoding === 'utf8')) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("return", response.text());

              case 10:
                if (!encoding) {
                  _context3.next = 12;
                  break;
                }

                throw new Error("unsupported encoding: ".concat(encoding));

              case 12:
                return _context3.abrupt("return", this.getBufferFromResponse(response));

              case 13:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function readFile() {
        return _readFile.apply(this, arguments);
      }

      return readFile;
    }()
  }, {
    key: "stat",
    value: function () {
      var _stat = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
        var buf;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this._stat) {
                  _context4.next = 6;
                  break;
                }

                buf = Buffer.allocUnsafe(10);
                _context4.next = 4;
                return this.read(buf, 0, 10, 0);

              case 4:
                if (this._stat) {
                  _context4.next = 6;
                  break;
                }

                throw new Error("unable to determine size of file at ".concat(this.url));

              case 6:
                return _context4.abrupt("return", this._stat);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function stat() {
        return _stat.apply(this, arguments);
      }

      return stat;
    }()
  }]);
  return RemoteFile;
}();

exports.default = RemoteFile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZW1vdGVGaWxlLnRzIl0sIm5hbWVzIjpbIm15R2xvYmFsIiwid2luZG93Iiwic2VsZiIsImZldGNoIiwidW5kZWZpbmVkIiwiUmVtb3RlRmlsZSIsInJlc3BvbnNlIiwiYnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJyZXNwIiwiQnVmZmVyIiwiZnJvbSIsIlR5cGVFcnJvciIsInNvdXJjZSIsIm9wdHMiLCJ1cmwiLCJzdGFydHNXaXRoIiwicGF0aCIsImxvY2FsRmlsZSIsIkxvY2FsRmlsZSIsInJlYWQiLCJiaW5kIiwicmVhZEZpbGUiLCJzdGF0Iiwib3ZlcnJpZGVzIiwiYmFzZU92ZXJyaWRlcyIsIm9mZnNldCIsImxlbmd0aCIsInBvc2l0aW9uIiwiaGVhZGVycyIsInNpZ25hbCIsIkluZmluaXR5IiwicmFuZ2UiLCJtZXRob2QiLCJyZWRpcmVjdCIsIm1vZGUiLCJzdGF0dXMiLCJnZXRCdWZmZXJGcm9tUmVzcG9uc2UiLCJyZXNwb25zZURhdGEiLCJieXRlc0NvcGllZCIsImNvcHkiLCJNYXRoIiwibWluIiwicmVzIiwiZ2V0Iiwic2l6ZU1hdGNoIiwiZXhlYyIsIl9zdGF0Iiwic2l6ZSIsInBhcnNlSW50IiwiYnl0ZXNSZWFkIiwiRXJyb3IiLCJvcHRpb25zIiwiZW5jb2RpbmciLCJPYmplY3QiLCJhc3NpZ24iLCJ0ZXh0IiwiYnVmIiwiYWxsb2NVbnNhZmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTs7Ozs7O0FBRUEsSUFBTUEsUUFBUSxHQUFHLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NBLE1BQWhDLEdBQXlDLE9BQU9DLElBQVAsS0FBZ0IsV0FBaEIsR0FBOEJBLElBQTlCLEdBQXFDO0FBQUVDLEVBQUFBLEtBQUssRUFBRUM7QUFBVCxDQUEvRjs7SUFFcUJDLFU7Ozs7NEhBTWlCQyxROzs7Ozs7c0JBQzlCLE9BQU9BLFFBQVEsQ0FBQ0MsTUFBaEIsS0FBMkIsVTs7Ozs7aURBQ3RCRCxRQUFR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a0IsRUFBbEIsRUFBc0IsQ0FBdEIsQzs7O29CQUNELEtBQUtWLEs7Ozs7O3NCQUFhLElBQUlJLEtBQUosK0NBQWlELEtBQUtwQyxHQUF0RCxFOzs7a0RBRWxCLEtBQUtnQyxLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHVyaTJwYXRoIGZyb20gJ2ZpbGUtdXJpLXRvLXBhdGgnXG5pbXBvcnQgeyBHZW5lcmljRmlsZWhhbmRsZSwgRmlsZWhhbmRsZU9wdGlvbnMsIFN0YXRzLCBGZXRjaGVyLCBQb2x5ZmlsbGVkUmVzcG9uc2UgfSBmcm9tICcuL2ZpbGVoYW5kbGUnXG5pbXBvcnQgeyBMb2NhbEZpbGUgfSBmcm9tICcuJ1xuXG5jb25zdCBteUdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHsgZmV0Y2g6IHVuZGVmaW5lZCB9XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbW90ZUZpbGUgaW1wbGVtZW50cyBHZW5lcmljRmlsZWhhbmRsZSB7XG4gIHByaXZhdGUgdXJsOiBzdHJpbmdcbiAgcHJpdmF0ZSBfc3RhdD86IFN0YXRzXG4gIHByaXZhdGUgZmV0Y2g6IEZldGNoZXJcbiAgcHJpdmF0ZSBiYXNlT3ZlcnJpZGVzOiBhbnkgPSB7fVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlOiBQb2x5ZmlsbGVkUmVzcG9uc2UpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuYnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuYnVmZmVyKClcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKClcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShyZXNwKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIEhUVFAgcmVzcG9uc2Ugb2JqZWN0LCBoYXMgbm8gYnVmZmVyIG1ldGhvZCwgYW5kIG5vIGFycmF5QnVmZmVyIG1ldGhvZCcpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHNvdXJjZTogc3RyaW5nLCBvcHRzOiBGaWxlaGFuZGxlT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy51cmwgPSBzb3VyY2VcblxuICAgIC8vIGlmIGl0IGlzIGEgZmlsZSBVUkwsIG1vbmtleS1wYXRjaCBvdXJzZWx2ZXMgdG8gYWN0IGxpa2UgYSBMb2NhbEZpbGVcbiAgICBpZiAoc291cmNlLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKSkge1xuICAgICAgY29uc3QgcGF0aCA9IHVyaTJwYXRoKHNvdXJjZSlcbiAgICAgIGlmICghcGF0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBmaWxlIHVybCcpXG4gICAgICBjb25zdCBsb2NhbEZpbGUgPSBuZXcgTG9jYWxGaWxlKHBhdGgpXG4gICAgICB0aGlzLnJlYWQgPSBsb2NhbEZpbGUucmVhZC5iaW5kKGxvY2FsRmlsZSlcbiAgICAgIHRoaXMucmVhZEZpbGUgPSBsb2NhbEZpbGUucmVhZEZpbGUuYmluZChsb2NhbEZpbGUpXG4gICAgICB0aGlzLnN0YXQgPSBsb2NhbEZpbGUuc3RhdC5iaW5kKGxvY2FsRmlsZSlcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5mZXRjaCA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgLyogaW50ZW50aW9uYWxseSBibGFuayAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZmV0Y2ggPSBvcHRzLmZldGNoIHx8IChteUdsb2JhbC5mZXRjaCAmJiBteUdsb2JhbC5mZXRjaC5iaW5kKG15R2xvYmFsKSlcbiAgICBpZiAoIWZldGNoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBubyBmZXRjaCBmdW5jdGlvbiBzdXBwbGllZCwgYW5kIG5vbmUgZm91bmQgaW4gZ2xvYmFsIGVudmlyb25tZW50YClcbiAgICB9XG4gICAgaWYgKG9wdHMub3ZlcnJpZGVzKSB7XG4gICAgICB0aGlzLmJhc2VPdmVycmlkZXMgPSBvcHRzLm92ZXJyaWRlc1xuICAgIH1cbiAgICB0aGlzLmZldGNoID0gZmV0Y2hcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByZWFkKFxuICAgIGJ1ZmZlcjogQnVmZmVyLFxuICAgIG9mZnNldCA9IDAsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgcG9zaXRpb24gPSAwLFxuICAgIG9wdHM6IEZpbGVoYW5kbGVPcHRpb25zID0ge30sXG4gICk6IFByb21pc2U8eyBieXRlc1JlYWQ6IG51bWJlcjsgYnVmZmVyOiBCdWZmZXIgfT4ge1xuICAgIGNvbnN0IHsgaGVhZGVycyA9IHt9LCBzaWduYWwsIG92ZXJyaWRlcyA9IHt9IH0gPSBvcHRzXG4gICAgaWYgKGxlbmd0aCA8IEluZmluaXR5KSB7XG4gICAgICBoZWFkZXJzLnJhbmdlID0gYGJ5dGVzPSR7cG9zaXRpb259LSR7cG9zaXRpb24gKyBsZW5ndGh9YFxuICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSBJbmZpbml0eSAmJiBwb3NpdGlvbiAhPT0gMCkge1xuICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS1gXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCB7XG4gICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgICBoZWFkZXJzOiB7IC4uLmhlYWRlcnMsIC4uLm92ZXJyaWRlcy5oZWFkZXJzLCAuLi50aGlzLmJhc2VPdmVycmlkZXMuaGVhZGVycyB9LFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHJlZGlyZWN0OiAnZm9sbG93JyxcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIHNpZ25hbCxcbiAgICB9KVxuXG4gICAgaWYgKChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiBwb3NpdGlvbiA9PT0gMCkgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKVxuICAgICAgY29uc3QgYnl0ZXNDb3BpZWQgPSByZXNwb25zZURhdGEuY29weShidWZmZXIsIG9mZnNldCwgMCwgTWF0aC5taW4obGVuZ3RoLCByZXNwb25zZURhdGEubGVuZ3RoKSlcblxuICAgICAgLy8gdHJ5IHRvIHBhcnNlIG91dCB0aGUgc2l6ZSBvZiB0aGUgcmVtb3RlIGZpbGVcbiAgICAgIGNvbnN0IHJlcyA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXJhbmdlJylcbiAgICAgIGNvbnN0IHNpemVNYXRjaCA9IC9cXC8oXFxkKykkLy5leGVjKHJlcyB8fCAnJylcbiAgICAgIGlmIChzaXplTWF0Y2ggJiYgc2l6ZU1hdGNoWzFdKSB0aGlzLl9zdGF0ID0geyBzaXplOiBwYXJzZUludChzaXplTWF0Y2hbMV0sIDEwKSB9XG5cbiAgICAgIHJldHVybiB7IGJ5dGVzUmVhZDogYnl0ZXNDb3BpZWQsIGJ1ZmZlciB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogdHJ5IGhhcmRlciBoZXJlIHRvIGdhdGhlciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgdGhlIHByb2JsZW0gaXNcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9IGZldGNoaW5nICR7dGhpcy51cmx9YClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByZWFkRmlsZShvcHRpb25zOiBGaWxlaGFuZGxlT3B0aW9ucyB8IHN0cmluZyA9IHt9KTogUHJvbWlzZTxCdWZmZXIgfCBzdHJpbmc+IHtcbiAgICBsZXQgZW5jb2RpbmdcbiAgICBsZXQgb3B0c1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gb3B0aW9uc1xuICAgICAgb3B0cyA9IHt9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZ1xuICAgICAgb3B0cyA9IG9wdGlvbnNcbiAgICAgIGRlbGV0ZSBvcHRzLmVuY29kaW5nXG4gICAgfVxuICAgIGNvbnN0IHsgaGVhZGVycyA9IHt9LCBzaWduYWwsIG92ZXJyaWRlcyA9IHt9IH0gPSBvcHRzXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHRoaXMudXJsLCB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIHJlZGlyZWN0OiAnZm9sbG93JyxcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIHNpZ25hbCxcbiAgICAgIC4uLnRoaXMuYmFzZU92ZXJyaWRlcyxcbiAgICAgIC4uLm92ZXJyaWRlcyxcbiAgICB9KVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9IGZldGNoaW5nICR7dGhpcy51cmx9YCksIHtcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1dGY4JykgcmV0dXJuIHJlc3BvbnNlLnRleHQoKVxuICAgIGlmIChlbmNvZGluZykgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBlbmNvZGluZzogJHtlbmNvZGluZ31gKVxuICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlckZyb21SZXNwb25zZShyZXNwb25zZSlcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzdGF0KCk6IFByb21pc2U8U3RhdHM+IHtcbiAgICBpZiAoIXRoaXMuX3N0YXQpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxMClcbiAgICAgIGF3YWl0IHRoaXMucmVhZChidWYsIDAsIDEwLCAwKVxuICAgICAgaWYgKCF0aGlzLl9zdGF0KSB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBkZXRlcm1pbmUgc2l6ZSBvZiBmaWxlIGF0ICR7dGhpcy51cmx9YClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRcbiAgfVxufVxuIl19
