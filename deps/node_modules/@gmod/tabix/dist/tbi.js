"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _construct = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/construct"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _long = _interopRequireDefault(require("long"));

var _virtualOffset = _interopRequireWildcard(require("./virtualOffset"));

var _chunk = _interopRequireDefault(require("./chunk"));

var _bgzfFilehandle = require("@gmod/bgzf-filehandle");

var _util = require("./util");

var _indexFile = _interopRequireDefault(require("./indexFile"));

function _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = (0, _construct.default)(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_construct.default) return false; if (_construct.default.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call((0, _construct.default)(Date, [], function () {})); return true; } catch (e) { return false; } }

var TBI_MAGIC = 21578324; // TBI\1

var TAD_LIDX_SHIFT = 14;
/**
 * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)
 * @returns {Array[number]}
 */

function reg2bins(beg, end) {
  beg += 1; // < convert to 1-based closed

  end -= 1;
  var list = [0];

  for (var k = 1 + (beg >> 26); k <= 1 + (end >> 26); k += 1) {
    list.push(k);
  }

  for (var _k = 9 + (beg >> 23); _k <= 9 + (end >> 23); _k += 1) {
    list.push(_k);
  }

  for (var _k2 = 73 + (beg >> 20); _k2 <= 73 + (end >> 20); _k2 += 1) {
    list.push(_k2);
  }

  for (var _k3 = 585 + (beg >> 17); _k3 <= 585 + (end >> 17); _k3 += 1) {
    list.push(_k3);
  }

  for (var _k4 = 4681 + (beg >> 14); _k4 <= 4681 + (end >> 14); _k4 += 1) {
    list.push(_k4);
  }

  return list;
}

var TabixIndex = /*#__PURE__*/function (_IndexFile) {
  (0, _inherits2.default)(TabixIndex, _IndexFile);

  var _super = _createSuper(TabixIndex);

  function TabixIndex() {
    (0, _classCallCheck2.default)(this, TabixIndex);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(TabixIndex, [{
    key: "lineCount",
    value: function () {
      var _lineCount = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(refName) {
        var opts,
            indexData,
            refId,
            idx,
            stats,
            _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return this.parse(opts);

              case 3:
                indexData = _context.sent;

                if (indexData) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", -1);

              case 6:
                refId = indexData.refNameToId[refName];
                idx = indexData.indices[refId];

                if (idx) {
                  _context.next = 10;
                  break;
                }

                return _context.abrupt("return", -1);

              case 10:
                stats = indexData.indices[refId].stats;

                if (!stats) {
                  _context.next = 13;
                  break;
                }

                return _context.abrupt("return", stats.lineCount);

              case 13:
                return _context.abrupt("return", -1);

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function lineCount(_x) {
        return _lineCount.apply(this, arguments);
      }

      return lineCount;
    }() // memoize
    // fetch and parse the index

  }, {
    key: "_parse",
    value: function () {
      var _parse2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var _this = this;

        var opts,
            bytes,
            refCount,
            formatFlags,
            coordinateType,
            formatOpts,
            format,
            columnNumbers,
            metaValue,
            depth,
            maxBinNumber,
            maxRefLength,
            metaChar,
            skipLines,
            nameSectionLength,
            _this$_parseNameBytes,
            refNameToId,
            refIdToName,
            currOffset,
            firstDataLine,
            indices,
            _args2 = arguments;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                opts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                _context2.t0 = _bgzfFilehandle.unzip;
                _context2.next = 4;
                return this.filehandle.readFile(opts);

              case 4:
                _context2.t1 = _context2.sent;
                _context2.next = 7;
                return (0, _context2.t0)(_context2.t1);

              case 7:
                bytes = _context2.sent;
                (0, _util.checkAbortSignal)(opts.signal); // check TBI magic numbers

                if (!(bytes.readUInt32LE(0) !== TBI_MAGIC
                /* "TBI\1" */
                )) {
                  _context2.next = 11;
                  break;
                }

                throw new Error('Not a TBI file');

              case 11:
                // number of reference sequences in the index
                refCount = bytes.readInt32LE(4);
                formatFlags = bytes.readInt32LE(8);
                coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';
                formatOpts = {
                  0: 'generic',
                  1: 'SAM',
                  2: 'VCF'
                };
                format = formatOpts[formatFlags & 0xf];

                if (format) {
                  _context2.next = 18;
                  break;
                }

                throw new Error("invalid Tabix preset format flags ".concat(formatFlags));

              case 18:
                columnNumbers = {
                  ref: bytes.readInt32LE(12),
                  start: bytes.readInt32LE(16),
                  end: bytes.readInt32LE(20)
                };
                metaValue = bytes.readInt32LE(24);
                depth = 5;
                maxBinNumber = ((1 << (depth + 1) * 3) - 1) / 7;
                maxRefLength = Math.pow(2, 14 + depth * 3);
                metaChar = metaValue ? String.fromCharCode(metaValue) : null;
                skipLines = bytes.readInt32LE(28); // read sequence dictionary

                nameSectionLength = bytes.readInt32LE(32);
                _this$_parseNameBytes = this._parseNameBytes(bytes.slice(36, 36 + nameSectionLength)), refNameToId = _this$_parseNameBytes.refNameToId, refIdToName = _this$_parseNameBytes.refIdToName; // read the indexes for each reference sequence

                currOffset = 36 + nameSectionLength;
                indices = new Array(refCount).fill(0).map(function () {
                  // the binning index
                  var binCount = bytes.readInt32LE(currOffset);
                  currOffset += 4;
                  var binIndex = {};
                  var stats;

                  for (var j = 0; j < binCount; j += 1) {
                    var bin = bytes.readUInt32LE(currOffset);
                    currOffset += 4;

                    if (bin > maxBinNumber + 1) {
                      throw new Error('tabix index contains too many bins, please use a CSI index');
                    } else if (bin === maxBinNumber + 1) {
                      var chunkCount = bytes.readInt32LE(currOffset);
                      currOffset += 4;

                      if (chunkCount === 2) {
                        stats = _this.parsePseudoBin(bytes, currOffset);
                      }

                      currOffset += 16 * chunkCount;
                    } else {
                      var _chunkCount = bytes.readInt32LE(currOffset);

                      currOffset += 4;
                      var chunks = new Array(_chunkCount);

                      for (var k = 0; k < _chunkCount; k += 1) {
                        var u = (0, _virtualOffset.fromBytes)(bytes, currOffset);
                        var v = (0, _virtualOffset.fromBytes)(bytes, currOffset + 8);
                        currOffset += 16;
                        firstDataLine = _this._findFirstData(firstDataLine, u);
                        chunks[k] = new _chunk.default(u, v, bin);
                      }

                      binIndex[bin] = chunks;
                    }
                  } // the linear index


                  var linearCount = bytes.readInt32LE(currOffset);
                  currOffset += 4;
                  var linearIndex = new Array(linearCount);

                  for (var _k5 = 0; _k5 < linearCount; _k5 += 1) {
                    linearIndex[_k5] = (0, _virtualOffset.fromBytes)(bytes, currOffset);
                    currOffset += 8;
                    firstDataLine = _this._findFirstData(firstDataLine, linearIndex[_k5]);
                  }

                  return {
                    binIndex: binIndex,
                    linearIndex: linearIndex,
                    stats: stats
                  };
                });
                return _context2.abrupt("return", {
                  indices: indices,
                  metaChar: metaChar,
                  maxBinNumber: maxBinNumber,
                  maxRefLength: maxRefLength,
                  skipLines: skipLines,
                  firstDataLine: firstDataLine,
                  columnNumbers: columnNumbers,
                  coordinateType: coordinateType,
                  format: format,
                  refIdToName: refIdToName,
                  refNameToId: refNameToId,
                  maxBlockSize: 1 << 16
                });

              case 30:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _parse() {
        return _parse2.apply(this, arguments);
      }

      return _parse;
    }()
  }, {
    key: "parsePseudoBin",
    value: function parsePseudoBin(bytes, offset) {
      var lineCount = (0, _util.longToNumber)(_long.default.fromBytesLE(bytes.slice(offset + 16, offset + 24), true));
      return {
        lineCount: lineCount
      };
    }
  }, {
    key: "_parseNameBytes",
    value: function _parseNameBytes(namesBytes) {
      var currRefId = 0;
      var currNameStart = 0;
      var refIdToName = [];
      var refNameToId = {};

      for (var i = 0; i < namesBytes.length; i += 1) {
        if (!namesBytes[i]) {
          if (currNameStart < i) {
            var refName = namesBytes.toString('utf8', currNameStart, i);
            refName = this.renameRefSeq(refName);
            refIdToName[currRefId] = refName;
            refNameToId[refName] = currRefId;
          }

          currNameStart = i + 1;
          currRefId += 1;
        }
      }

      return {
        refNameToId: refNameToId,
        refIdToName: refIdToName
      };
    }
  }, {
    key: "blocksForRange",
    value: function () {
      var _blocksForRange = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(refName, beg, end) {
        var opts,
            indexData,
            refId,
            indexes,
            linearIndex,
            binIndex,
            bins,
            minOffset,
            l,
            numOffsets,
            i,
            off,
            _i,
            chunks,
            j,
            _i2,
            _i3,
            _i4,
            _args3 = arguments;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {};
                if (beg < 0) beg = 0;
                _context3.next = 4;
                return this.parse(opts);

              case 4:
                indexData = _context3.sent;

                if (indexData) {
                  _context3.next = 7;
                  break;
                }

                return _context3.abrupt("return", []);

              case 7:
                refId = indexData.refNameToId[refName];
                indexes = indexData.indices[refId];

                if (indexes) {
                  _context3.next = 11;
                  break;
                }

                return _context3.abrupt("return", []);

              case 11:
                linearIndex = indexes.linearIndex, binIndex = indexes.binIndex;
                bins = reg2bins(beg, end);
                minOffset = linearIndex.length ? linearIndex[beg >> TAD_LIDX_SHIFT >= linearIndex.length ? linearIndex.length - 1 : beg >> TAD_LIDX_SHIFT] : new _virtualOffset.default(0, 0);

                if (minOffset) {
                  _context3.next = 17;
                  break;
                }

                console.warn('querying outside of possible tabix range');
                return _context3.abrupt("return", []);

              case 17:
                numOffsets = 0;

                for (i = 0; i < bins.length; i += 1) {
                  if (binIndex[bins[i]]) numOffsets += binIndex[bins[i]].length;
                }

                if (!(numOffsets === 0)) {
                  _context3.next = 21;
                  break;
                }

                return _context3.abrupt("return", []);

              case 21:
                off = [];
                numOffsets = 0;

                for (_i = 0; _i < bins.length; _i += 1) {
                  chunks = binIndex[bins[_i]];
                  if (chunks) for (j = 0; j < chunks.length; j += 1) {
                    if (minOffset.compareTo(chunks[j].maxv) < 0) {
                      off[numOffsets] = new _chunk.default(chunks[j].minv, chunks[j].maxv, chunks[j].bin);
                      numOffsets += 1;
                    }
                  }
                }

                if (off.length) {
                  _context3.next = 26;
                  break;
                }

                return _context3.abrupt("return", []);

              case 26:
                off = off.sort(function (a, b) {
                  return a.compareTo(b);
                }); // resolve completely contained adjacent blocks

                l = 0;

                for (_i2 = 1; _i2 < numOffsets; _i2 += 1) {
                  if (off[l].maxv.compareTo(off[_i2].maxv) < 0) {
                    l += 1;
                    off[l].minv = off[_i2].minv;
                    off[l].maxv = off[_i2].maxv;
                  }
                }

                numOffsets = l + 1; // resolve overlaps between adjacent blocks; this may happen due to the merge in indexing

                for (_i3 = 1; _i3 < numOffsets; _i3 += 1) {
                  if (off[_i3 - 1].maxv.compareTo(off[_i3].minv) >= 0) {
                    off[_i3 - 1].maxv = off[_i3].minv;
                  }
                } // merge adjacent blocks


                l = 0;

                for (_i4 = 1; _i4 < numOffsets; _i4 += 1) {
                  if (off[l].maxv.blockPosition === off[_i4].minv.blockPosition) off[l].maxv = off[_i4].maxv;else {
                    l += 1;
                    off[l].minv = off[_i4].minv;
                    off[l].maxv = off[_i4].maxv;
                  }
                }

                numOffsets = l + 1;
                return _context3.abrupt("return", off.slice(0, numOffsets));

              case 35:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function blocksForRange(_x2, _x3, _x4) {
        return _blocksForRange.apply(this, arguments);
      }

      return blocksForRange;
    }()
  }]);
  return TabixIndex;
}(_indexFile.default);

exports.default = TabixIndex;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90YmkudHMiXSwibmFtZXMiOlsiVEJJX01BR0lDIiwiVEFEX0xJRFhfU0hJRlQiLCJyZWcyYmlucyIsImJlZyIsImVuZCIsImxpc3QiLCJrIiwicHVzaCIsIlRhYml4SW5kZXgiLCJyZWZOYW1lIiwib3B0cyIsInBhcnNlIiwiaW5kZXhEYXRhIiwicmVmSWQiLCJyZWZOYW1lVG9JZCIsImlkeCIsImluZGljZXMiLCJzdGF0cyIsImxpbmVDb3VudCIsInVuemlwIiwiZmlsZWhhbmRsZSIsInJlYWRGaWxlIiwiYnl0ZXMiLCJzaWduYWwiLCJyZWFkVUludDMyTEUiLCJFcnJvciIsInJlZkNvdW50IiwicmVhZEludDMyTEUiLCJmb3JtYXRGbGFncyIsImNvb3JkaW5hdGVUeXBlIiwiZm9ybWF0T3B0cyIsImZvcm1hdCIsImNvbHVtbk51bWJlcnMiLCJyZWYiLCJzdGFydCIsIm1ldGFWYWx1ZSIsImRlcHRoIiwibWF4QmluTnVtYmVyIiwibWF4UmVmTGVuZ3RoIiwibWV0YUNoYXIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJza2lwTGluZXMiLCJuYW1lU2VjdGlvbkxlbmd0aCIsIl9wYXJzZU5hbWVCeXRlcyIsInNsaWNlIiwicmVmSWRUb05hbWUiLCJjdXJyT2Zmc2V0IiwiQXJyYXkiLCJmaWxsIiwibWFwIiwiYmluQ291bnQiLCJiaW5JbmRleCIsImoiLCJiaW4iLCJjaHVua0NvdW50IiwicGFyc2VQc2V1ZG9CaW4iLCJjaHVua3MiLCJ1IiwidiIsImZpcnN0RGF0YUxpbmUiLCJfZmluZEZpcnN0RGF0YSIsIkNodW5rIiwibGluZWFyQ291bnQiLCJsaW5lYXJJbmRleCIsIm1heEJsb2NrU2l6ZSIsIm9mZnNldCIsIkxvbmciLCJmcm9tQnl0ZXNMRSIsIm5hbWVzQnl0ZXMiLCJjdXJyUmVmSWQiLCJjdXJyTmFtZVN0YXJ0IiwiaSIsImxlbmd0aCIsInRvU3RyaW5nIiwicmVuYW1lUmVmU2VxIiwiaW5kZXhlcyIsImJpbnMiLCJtaW5PZmZzZXQiLCJWaXJ0dWFsT2Zmc2V0IiwiY29uc29sZSIsIndhcm4iLCJudW1PZmZzZXRzIiwib2ZmIiwiY29tcGFyZVRvIiwibWF4diIsIm1pbnYiLCJzb3J0IiwiYSIsImIiLCJsIiwiYmxvY2tQb3NpdGlvbiIsIkluZGV4RmlsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBLElBQU1BLFNBQVMsR0FBRyxRQUFsQixDLENBQTJCOztBQUMzQixJQUFNQyxjQUFjLEdBQUcsRUFBdkI7QUFFQTs7Ozs7QUFJQSxTQUFTQyxRQUFULENBQWtCQyxHQUFsQixFQUErQkMsR0FBL0IsRUFBNEM7QUFDMUNELEVBQUFBLEdBQUcsSUFBSSxDQUFQLENBRDBDLENBQ2pDOztBQUNUQyxFQUFBQSxHQUFHLElBQUksQ0FBUDtBQUNBLE1BQU1DLElBQUksR0FBRyxDQUFDLENBQUQsQ0FBYjs7QUFDQSxPQUFLLElBQUlDLENBQUMsR0FBRyxLQUFLSCxHQUFHLElBQUksRUFBWixDQUFiLEVBQThCRyxDQUFDLElBQUksS0FBS0YsR0FBRyxJQUFJLEVBQVosQ0FBbkMsRUFBb0RFLENBQUMsSUFBSSxDQUF6RDtBQUE0REQsSUFBQUEsSUFBSSxDQUFDRSxJQUFMLENBQVVELENBQVY7QUFBNUQ7O0FBQ0EsT0FBSyxJQUFJQSxFQUFDLEdBQUcsS0FBS0gsR0FBRyxJQUFJLEVBQVosQ0FBYixFQUE4QkcsRUFBQyxJQUFJLEtBQUtGLEdBQUcsSUFBSSxFQUFaLENBQW5DLEVBQW9ERSxFQUFDLElBQUksQ0FBekQ7QUFBNERELElBQUFBLElBQUksQ0FBQ0UsSUFBTCxDQUFVRCxFQUFWO0FBQTVEOztBQUNBLE9BQUssSUFBSUEsR0FBQyxHQUFHLE1BQU1ILEdBQUcsSUFBSSxFQUFiLENBQWIsRUFBK0JHLEdBQUMsSUFBSSxNQUFNRixHQUFHLElBQUksRUFBYixDQUFwQyxFQUFzREUsR0FBQyxJQUFJLENBQTNEO0FBQThERCxJQUFBQSxJ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VUFBcEIsRUFBZ0NWLEdBQUMsSUFBSSxDQUFyQyxFQUF3QztBQUN0QyxzQkFBSVcsR0FBRyxDQUFDTyxDQUFELENBQUgsQ0FBT0wsSUFBUCxDQUFZTSxhQUFaLEtBQThCUixHQUFHLENBQUNYLEdBQUQsQ0FBSCxDQUFPYyxJQUFQLENBQVlLLGFBQTlDLEVBQ0VSLEdBQUcsQ0FBQ08sQ0FBRCxDQUFILENBQU9MLElBQVAsR0FBY0YsR0FBRyxDQUFDWCxHQUFELENBQUgsQ0FBT2EsSUFBckIsQ0FERixLQUVLO0FBQ0hLLG9CQUFBQSxDQUFDLElBQUksQ0FBTDtBQUNBUCxvQkFBQUEsR0FBRyxDQUFDTyxDQUFELENBQUgsQ0FBT0osSUFBUCxHQUFjSCxHQUFHLENBQUNYLEdBQUQsQ0FBSCxDQUFPYyxJQUFyQjtBQUNBSCxvQkFBQUEsR0FBRyxDQUFDTyxDQUFELENBQUgsQ0FBT0wsSUFBUCxHQUFjRixHQUFHLENBQUNYLEdBQUQsQ0FBSCxDQUFPYSxJQUFyQjtBQUNEO0FBQ0Y7O0FBQ0RILGdCQUFBQSxVQUFVLEdBQUdRLENBQUMsR0FBRyxDQUFqQjtrREFFT1AsR0FBRyxDQUFDdEMsS0FBSixDQUFVLENBQVYsRUFBYXFDLFVBQWIsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBaFA2QlUsa0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTG9uZyBmcm9tICdsb25nJ1xuaW1wb3J0IFZpcnR1YWxPZmZzZXQsIHsgZnJvbUJ5dGVzIH0gZnJvbSAnLi92aXJ0dWFsT2Zmc2V0J1xuaW1wb3J0IENodW5rIGZyb20gJy4vY2h1bmsnXG5pbXBvcnQgeyB1bnppcCB9IGZyb20gJ0BnbW9kL2JnemYtZmlsZWhhbmRsZSdcbmltcG9ydCB7IGxvbmdUb051bWJlciwgY2hlY2tBYm9ydFNpZ25hbCB9IGZyb20gJy4vdXRpbCdcbmltcG9ydCBJbmRleEZpbGUsIHsgT3B0aW9ucyB9IGZyb20gJy4vaW5kZXhGaWxlJ1xuXG5jb25zdCBUQklfTUFHSUMgPSAyMTU3ODMyNCAvLyBUQklcXDFcbmNvbnN0IFRBRF9MSURYX1NISUZUID0gMTRcblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGxpc3Qgb2YgYmlucyB0aGF0IG1heSBvdmVybGFwIHdpdGggcmVnaW9uIFtiZWcsZW5kKSAoemVyby1iYXNlZCBoYWxmLW9wZW4pXG4gKiBAcmV0dXJucyB7QXJyYXlbbnVtYmVyXX1cbiAqL1xuZnVuY3Rpb24gcmVnMmJpbnMoYmVnOiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gIGJlZyArPSAxIC8vIDwgY29udmVydCB0byAxLWJhc2VkIGNsb3NlZFxuICBlbmQgLT0gMVxuICBjb25zdCBsaXN0ID0gWzBdXG4gIGZvciAobGV0IGsgPSAxICsgKGJlZyA+PiAyNik7IGsgPD0gMSArIChlbmQgPj4gMjYpOyBrICs9IDEpIGxpc3QucHVzaChrKVxuICBmb3IgKGxldCBrID0gOSArIChiZWcgPj4gMjMpOyBrIDw9IDkgKyAoZW5kID4+IDIzKTsgayArPSAxKSBsaXN0LnB1c2goaylcbiAgZm9yIChsZXQgayA9IDczICsgKGJlZyA+PiAyMCk7IGsgPD0gNzMgKyAoZW5kID4+IDIwKTsgayArPSAxKSBsaXN0LnB1c2goaylcbiAgZm9yIChsZXQgayA9IDU4NSArIChiZWcgPj4gMTcpOyBrIDw9IDU4NSArIChlbmQgPj4gMTcpOyBrICs9IDEpIGxpc3QucHVzaChrKVxuICBmb3IgKGxldCBrID0gNDY4MSArIChiZWcgPj4gMTQpOyBrIDw9IDQ2ODEgKyAoZW5kID4+IDE0KTsgayArPSAxKSBsaXN0LnB1c2goaylcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFiaXhJbmRleCBleHRlbmRzIEluZGV4RmlsZSB7XG4gIGFzeW5jIGxpbmVDb3VudChyZWZOYW1lOiBzdHJpbmcsIG9wdHM6IE9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cylcbiAgICBpZiAoIWluZGV4RGF0YSkgcmV0dXJuIC0xXG4gICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV1cbiAgICBjb25zdCBpZHggPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF1cbiAgICBpZiAoIWlkeCkgcmV0dXJuIC0xXG4gICAgY29uc3QgeyBzdGF0cyB9ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdXG4gICAgaWYgKHN0YXRzKSByZXR1cm4gc3RhdHMubGluZUNvdW50XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBtZW1vaXplXG4gIC8vIGZldGNoIGFuZCBwYXJzZSB0aGUgaW5kZXhcbiAgYXN5bmMgX3BhcnNlKG9wdHM6IE9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdW56aXAoKGF3YWl0IHRoaXMuZmlsZWhhbmRsZS5yZWFkRmlsZShvcHRzKSkgYXMgQnVmZmVyKVxuICAgIGNoZWNrQWJvcnRTaWduYWwob3B0cy5zaWduYWwpXG5cbiAgICAvLyBjaGVjayBUQkkgbWFnaWMgbnVtYmVyc1xuICAgIGlmIChieXRlcy5yZWFkVUludDMyTEUoMCkgIT09IFRCSV9NQUdJQyAvKiBcIlRCSVxcMVwiICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIFRCSSBmaWxlJylcbiAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdG8gc3VwcG9ydCBiaWctZW5kaWFuIFRCSSBmaWxlcz9cbiAgICB9XG5cbiAgICAvLyBudW1iZXIgb2YgcmVmZXJlbmNlIHNlcXVlbmNlcyBpbiB0aGUgaW5kZXhcbiAgICBjb25zdCByZWZDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDQpXG4gICAgY29uc3QgZm9ybWF0RmxhZ3MgPSBieXRlcy5yZWFkSW50MzJMRSg4KVxuICAgIGNvbnN0IGNvb3JkaW5hdGVUeXBlID1cbiAgICAgIGZvcm1hdEZsYWdzICYgMHgxMDAwMCA/ICd6ZXJvLWJhc2VkLWhhbGYtb3BlbicgOiAnMS1iYXNlZC1jbG9zZWQnXG4gICAgY29uc3QgZm9ybWF0T3B0czogeyBba2V5OiBudW1iZXJdOiBzdHJpbmcgfSA9IHtcbiAgICAgIDA6ICdnZW5lcmljJyxcbiAgICAgIDE6ICdTQU0nLFxuICAgICAgMjogJ1ZDRicsXG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdE9wdHNbZm9ybWF0RmxhZ3MgJiAweGZdXG4gICAgaWYgKCFmb3JtYXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgVGFiaXggcHJlc2V0IGZvcm1hdCBmbGFncyAke2Zvcm1hdEZsYWdzfWApXG4gICAgY29uc3QgY29sdW1uTnVtYmVycyA9IHtcbiAgICAgIHJlZjogYnl0ZXMucmVhZEludDMyTEUoMTIpLFxuICAgICAgc3RhcnQ6IGJ5dGVzLnJlYWRJbnQzMkxFKDE2KSxcbiAgICAgIGVuZDogYnl0ZXMucmVhZEludDMyTEUoMjApLFxuICAgIH1cbiAgICBjb25zdCBtZXRhVmFsdWUgPSBieXRlcy5yZWFkSW50MzJMRSgyNClcbiAgICBjb25zdCBkZXB0aCA9IDVcbiAgICBjb25zdCBtYXhCaW5OdW1iZXIgPSAoKDEgPDwgKChkZXB0aCArIDEpICogMykpIC0gMSkgLyA3XG4gICAgY29uc3QgbWF4UmVmTGVuZ3RoID0gMiAqKiAoMTQgKyBkZXB0aCAqIDMpXG4gICAgY29uc3QgbWV0YUNoYXIgPSBtZXRhVmFsdWUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKG1ldGFWYWx1ZSkgOiBudWxsXG4gICAgY29uc3Qgc2tpcExpbmVzID0gYnl0ZXMucmVhZEludDMyTEUoMjgpXG5cbiAgICAvLyByZWFkIHNlcXVlbmNlIGRpY3Rpb25hcnlcbiAgICBjb25zdCBuYW1lU2VjdGlvbkxlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDMyKVxuICAgIGNvbnN0IHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH0gPSB0aGlzLl9wYXJzZU5hbWVCeXRlcyhcbiAgICAgIGJ5dGVzLnNsaWNlKDM2LCAzNiArIG5hbWVTZWN0aW9uTGVuZ3RoKSxcbiAgICApXG5cbiAgICAvLyByZWFkIHRoZSBpbmRleGVzIGZvciBlYWNoIHJlZmVyZW5jZSBzZXF1ZW5jZVxuICAgIGxldCBjdXJyT2Zmc2V0ID0gMzYgKyBuYW1lU2VjdGlvbkxlbmd0aFxuICAgIGxldCBmaXJzdERhdGFMaW5lOiBWaXJ0dWFsT2Zmc2V0IHwgdW5kZWZpbmVkXG4gICAgY29uc3QgaW5kaWNlcyA9IG5ldyBBcnJheShyZWZDb3VudCkuZmlsbCgwKS5tYXAoKCkgPT4ge1xuICAgICAgLy8gdGhlIGJpbm5pbmcgaW5kZXhcbiAgICAgIGNvbnN0IGJpbkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldClcbiAgICAgIGN1cnJPZmZzZXQgKz0gNFxuICAgICAgY29uc3QgYmluSW5kZXg6IHsgW2tleTogbnVtYmVyXTogQ2h1bmtbXSB9ID0ge31cbiAgICAgIGxldCBzdGF0c1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiaW5Db3VudDsgaiArPSAxKSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGJ5dGVzLnJlYWRVSW50MzJMRShjdXJyT2Zmc2V0KVxuICAgICAgICBjdXJyT2Zmc2V0ICs9IDRcbiAgICAgICAgaWYgKGJpbiA+IG1heEJpbk51bWJlciArIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAndGFiaXggaW5kZXggY29udGFpbnMgdG9vIG1hbnkgYmlucywgcGxlYXNlIHVzZSBhIENTSSBpbmRleCcsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKGJpbiA9PT0gbWF4QmluTnVtYmVyICsgMSkge1xuICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KVxuICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNFxuICAgICAgICAgIGlmIChjaHVua0NvdW50ID09PSAyKSB7XG4gICAgICAgICAgICBzdGF0cyA9IHRoaXMucGFyc2VQc2V1ZG9CaW4oYnl0ZXMsIGN1cnJPZmZzZXQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTYgKiBjaHVua0NvdW50XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpXG4gICAgICAgICAgY3Vyck9mZnNldCArPSA0XG4gICAgICAgICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ291bnQpXG4gICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjaHVua0NvdW50OyBrICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQpXG4gICAgICAgICAgICBjb25zdCB2ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgOClcbiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTZcbiAgICAgICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIHUpXG4gICAgICAgICAgICBjaHVua3Nba10gPSBuZXcgQ2h1bmsodSwgdiwgYmluKVxuICAgICAgICAgIH1cbiAgICAgICAgICBiaW5JbmRleFtiaW5dID0gY2h1bmtzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdGhlIGxpbmVhciBpbmRleFxuICAgICAgY29uc3QgbGluZWFyQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KVxuICAgICAgY3Vyck9mZnNldCArPSA0XG4gICAgICBjb25zdCBsaW5lYXJJbmRleCA9IG5ldyBBcnJheShsaW5lYXJDb3VudClcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGluZWFyQ291bnQ7IGsgKz0gMSkge1xuICAgICAgICBsaW5lYXJJbmRleFtrXSA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldClcbiAgICAgICAgY3Vyck9mZnNldCArPSA4XG4gICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIGxpbmVhckluZGV4W2tdKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgYmluSW5kZXgsIGxpbmVhckluZGV4LCBzdGF0cyB9XG4gICAgfSlcblxuICAgIHJldHVybiB7XG4gICAgICBpbmRpY2VzLFxuICAgICAgbWV0YUNoYXIsXG4gICAgICBtYXhCaW5OdW1iZXIsXG4gICAgICBtYXhSZWZMZW5ndGgsXG4gICAgICBza2lwTGluZXMsXG4gICAgICBmaXJzdERhdGFMaW5lLFxuICAgICAgY29sdW1uTnVtYmVycyxcbiAgICAgIGNvb3JkaW5hdGVUeXBlLFxuICAgICAgZm9ybWF0LFxuICAgICAgcmVmSWRUb05hbWUsXG4gICAgICByZWZOYW1lVG9JZCxcbiAgICAgIG1heEJsb2NrU2l6ZTogMSA8PCAxNixcbiAgICB9XG4gIH1cblxuICBwYXJzZVBzZXVkb0JpbihieXRlczogQnVmZmVyLCBvZmZzZXQ6IG51bWJlcikge1xuICAgIGNvbnN0IGxpbmVDb3VudCA9IGxvbmdUb051bWJlcihcbiAgICAgIExvbmcuZnJvbUJ5dGVzTEUoXG4gICAgICAgIChieXRlcy5zbGljZShvZmZzZXQgKyAxNiwgb2Zmc2V0ICsgMjQpIGFzIHVua25vd24pIGFzIG51bWJlcltdLFxuICAgICAgICB0cnVlLFxuICAgICAgKSxcbiAgICApXG4gICAgcmV0dXJuIHsgbGluZUNvdW50IH1cbiAgfVxuXG4gIF9wYXJzZU5hbWVCeXRlcyhuYW1lc0J5dGVzOiBCdWZmZXIpIHtcbiAgICBsZXQgY3VyclJlZklkID0gMFxuICAgIGxldCBjdXJyTmFtZVN0YXJ0ID0gMFxuICAgIGNvbnN0IHJlZklkVG9OYW1lOiBzdHJpbmdbXSA9IFtdXG4gICAgY29uc3QgcmVmTmFtZVRvSWQ6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7fVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNCeXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKCFuYW1lc0J5dGVzW2ldKSB7XG4gICAgICAgIGlmIChjdXJyTmFtZVN0YXJ0IDwgaSkge1xuICAgICAgICAgIGxldCByZWZOYW1lID0gbmFtZXNCeXRlcy50b1N0cmluZygndXRmOCcsIGN1cnJOYW1lU3RhcnQsIGkpXG4gICAgICAgICAgcmVmTmFtZSA9IHRoaXMucmVuYW1lUmVmU2VxKHJlZk5hbWUpXG4gICAgICAgICAgcmVmSWRUb05hbWVbY3VyclJlZklkXSA9IHJlZk5hbWVcbiAgICAgICAgICByZWZOYW1lVG9JZFtyZWZOYW1lXSA9IGN1cnJSZWZJZFxuICAgICAgICB9XG4gICAgICAgIGN1cnJOYW1lU3RhcnQgPSBpICsgMVxuICAgICAgICBjdXJyUmVmSWQgKz0gMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZOYW1lVG9JZCwgcmVmSWRUb05hbWUgfVxuICB9XG5cbiAgYXN5bmMgYmxvY2tzRm9yUmFuZ2UoXG4gICAgcmVmTmFtZTogc3RyaW5nLFxuICAgIGJlZzogbnVtYmVyLFxuICAgIGVuZDogbnVtYmVyLFxuICAgIG9wdHM6IE9wdGlvbnMgPSB7fSxcbiAgKSB7XG4gICAgaWYgKGJlZyA8IDApIGJlZyA9IDBcblxuICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cylcbiAgICBpZiAoIWluZGV4RGF0YSkgcmV0dXJuIFtdXG4gICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV1cbiAgICBjb25zdCBpbmRleGVzID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdXG4gICAgaWYgKCFpbmRleGVzKSByZXR1cm4gW11cblxuICAgIGNvbnN0IHsgbGluZWFySW5kZXgsIGJpbkluZGV4IH0gPSBpbmRleGVzXG5cbiAgICBjb25zdCBiaW5zID0gcmVnMmJpbnMoYmVnLCBlbmQpXG5cbiAgICBjb25zdCBtaW5PZmZzZXQgPSBsaW5lYXJJbmRleC5sZW5ndGhcbiAgICAgID8gbGluZWFySW5kZXhbXG4gICAgICAgICAgYmVnID4+IFRBRF9MSURYX1NISUZUID49IGxpbmVhckluZGV4Lmxlbmd0aFxuICAgICAgICAgICAgPyBsaW5lYXJJbmRleC5sZW5ndGggLSAxXG4gICAgICAgICAgICA6IGJlZyA+PiBUQURfTElEWF9TSElGVFxuICAgICAgICBdXG4gICAgICA6IG5ldyBWaXJ0dWFsT2Zmc2V0KDAsIDApXG4gICAgaWYgKCFtaW5PZmZzZXQpIHtcbiAgICAgIGNvbnNvbGUud2FybigncXVlcnlpbmcgb3V0c2lkZSBvZiBwb3NzaWJsZSB0YWJpeCByYW5nZScpXG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBsZXQgbFxuICAgIGxldCBudW1PZmZzZXRzID0gMFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmlucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGJpbkluZGV4W2JpbnNbaV1dKSBudW1PZmZzZXRzICs9IGJpbkluZGV4W2JpbnNbaV1dLmxlbmd0aFxuICAgIH1cblxuICAgIGlmIChudW1PZmZzZXRzID09PSAwKSByZXR1cm4gW11cblxuICAgIGxldCBvZmYgPSBbXVxuICAgIG51bU9mZnNldHMgPSAwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBjaHVua3MgPSBiaW5JbmRleFtiaW5zW2ldXVxuICAgICAgaWYgKGNodW5rcylcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaHVua3MubGVuZ3RoOyBqICs9IDEpXG4gICAgICAgICAgaWYgKG1pbk9mZnNldC5jb21wYXJlVG8oY2h1bmtzW2pdLm1heHYpIDwgMCkge1xuICAgICAgICAgICAgb2ZmW251bU9mZnNldHNdID0gbmV3IENodW5rKFxuICAgICAgICAgICAgICBjaHVua3Nbal0ubWludixcbiAgICAgICAgICAgICAgY2h1bmtzW2pdLm1heHYsXG4gICAgICAgICAgICAgIGNodW5rc1tqXS5iaW4sXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBudW1PZmZzZXRzICs9IDFcbiAgICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFvZmYubGVuZ3RoKSByZXR1cm4gW11cblxuICAgIG9mZiA9IG9mZi5zb3J0KChhLCBiKSA9PiBhLmNvbXBhcmVUbyhiKSlcblxuICAgIC8vIHJlc29sdmUgY29tcGxldGVseSBjb250YWluZWQgYWRqYWNlbnQgYmxvY2tzXG4gICAgbCA9IDBcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bU9mZnNldHM7IGkgKz0gMSkge1xuICAgICAgaWYgKG9mZltsXS5tYXh2LmNvbXBhcmVUbyhvZmZbaV0ubWF4dikgPCAwKSB7XG4gICAgICAgIGwgKz0gMVxuICAgICAgICBvZmZbbF0ubWludiA9IG9mZltpXS5taW52XG4gICAgICAgIG9mZltsXS5tYXh2ID0gb2ZmW2ldLm1heHZcbiAgICAgIH1cbiAgICB9XG4gICAgbnVtT2Zmc2V0cyA9IGwgKyAxXG5cbiAgICAvLyByZXNvbHZlIG92ZXJsYXBzIGJldHdlZW4gYWRqYWNlbnQgYmxvY2tzOyB0aGlzIG1heSBoYXBwZW4gZHVlIHRvIHRoZSBtZXJnZSBpbiBpbmRleGluZ1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtT2Zmc2V0czsgaSArPSAxKSB7XG4gICAgICBpZiAob2ZmW2kgLSAxXS5tYXh2LmNvbXBhcmVUbyhvZmZbaV0ubWludikgPj0gMCkge1xuICAgICAgICBvZmZbaSAtIDFdLm1heHYgPSBvZmZbaV0ubWludlxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1lcmdlIGFkamFjZW50IGJsb2Nrc1xuICAgIGwgPSAwXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1PZmZzZXRzOyBpICs9IDEpIHtcbiAgICAgIGlmIChvZmZbbF0ubWF4di5ibG9ja1Bvc2l0aW9uID09PSBvZmZbaV0ubWludi5ibG9ja1Bvc2l0aW9uKVxuICAgICAgICBvZmZbbF0ubWF4diA9IG9mZltpXS5tYXh2XG4gICAgICBlbHNlIHtcbiAgICAgICAgbCArPSAxXG4gICAgICAgIG9mZltsXS5taW52ID0gb2ZmW2ldLm1pbnZcbiAgICAgICAgb2ZmW2xdLm1heHYgPSBvZmZbaV0ubWF4dlxuICAgICAgfVxuICAgIH1cbiAgICBudW1PZmZzZXRzID0gbCArIDFcblxuICAgIHJldHVybiBvZmYuc2xpY2UoMCwgbnVtT2Zmc2V0cylcbiAgfVxufVxuIl19