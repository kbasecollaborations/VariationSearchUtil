"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/parse-int"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _abortablePromiseCache = _interopRequireDefault(require("abortable-promise-cache"));

var _quickLru = _interopRequireDefault(require("quick-lru"));

var _genericFilehandle = require("generic-filehandle");

var _bgzfFilehandle = require("@gmod/bgzf-filehandle");

var _util = require("./util");

var _tbi = _interopRequireDefault(require("./tbi"));

var _csi = _interopRequireDefault(require("./csi"));

function timeout(time) {
  return new _promise.default(function (resolve) {
    setTimeout(resolve, time);
  });
}

var TabixIndexedFile = /*#__PURE__*/function () {
  /**
   * @param {object} args
   * @param {string} [args.path]
   * @param {filehandle} [args.filehandle]
   * @param {string} [args.tbiPath]
   * @param {filehandle} [args.tbiFilehandle]
   * @param {string} [args.csiPath]
   * @param {filehandle} [args.csiFilehandle]
   * @param {number} [args.chunkSizeLimit] maximum number of bytes to fetch in a single `getLines` call.
   * default 2MiB
   * @param {number} [args.yieldLimit] maximum number of lines to parse without yielding.
   * this avoids having a large read prevent any other work getting done on the thread.  default 300 lines.
   * @param {function} [args.renameRefSeqs] optional function with sig `string => string` to transform
   * reference sequence names for the purpose of indexing and querying. note that the data that is returned is
   * not altered, just the names of the reference sequences that are used for querying.
   * @param {number} [args.chunkCacheSize] maximum size in bytes of the chunk cache. default 5MB
   * @param {number} [args.blockCacheSize] maximum size in bytes of the block cache. default 5MB
   */
  function TabixIndexedFile(_ref) {
    var path = _ref.path,
        filehandle = _ref.filehandle,
        tbiPath = _ref.tbiPath,
        tbiFilehandle = _ref.tbiFilehandle,
        csiPath = _ref.csiPath,
        csiFilehandle = _ref.csiFilehandle,
        _ref$chunkSizeLimit = _ref.chunkSizeLimit,
        chunkSizeLimit = _ref$chunkSizeLimit === void 0 ? 2000000 : _ref$chunkSizeLimit,
        _ref$yieldLimit = _ref.yieldLimit,
        yieldLimit = _ref$yieldLimit === void 0 ? 300 : _ref$yieldLimit,
        _ref$renameRefSeqs = _ref.renameRefSeqs,
        renameRefSeqs = _ref$renameRefSeqs === void 0 ? function (n) {
      return n;
    } : _ref$renameRefSeqs,
        _ref$chunkCacheSize = _ref.chunkCacheSize,
        chunkCacheSize = _ref$chunkCacheSize === void 0 ? 5 * Math.pow(2, 20) : _ref$chunkCacheSize;
    (0, _classCallCheck2.default)(this, TabixIndexedFile);
    (0, _defineProperty2.default)(this, "filehandle", void 0);
    (0, _defineProperty2.default)(this, "index", void 0);
    (0, _defineProperty2.default)(this, "chunkSizeLimit", void 0);
    (0, _defineProperty2.default)(this, "renameRefSeq", void 0);
    (0, _defineProperty2.default)(this, "yieldLimit", void 0);
    (0, _defineProperty2.default)(this, "chunkCache", void 0);
    if (filehandle) this.filehandle = filehandle;else if (path) this.filehandle = new _genericFilehandle.LocalFile(path);else throw new TypeError('must provide either filehandle or path');
    if (tbiFilehandle) this.index = new _tbi.default({
      filehandle: tbiFilehandle,
      renameRefSeqs: renameRefSeqs
    });else if (csiFilehandle) this.index = new _csi.default({
      filehandle: csiFilehandle,
      renameRefSeqs: renameRefSeqs
    });else if (tbiPath) this.index = new _tbi.default({
      filehandle: new _genericFilehandle.LocalFile(tbiPath),
      renameRefSeqs: renameRefSeqs
    });else if (csiPath) this.index = new _csi.default({
      filehandle: new _genericFilehandle.LocalFile(csiPath),
      renameRefSeqs: renameRefSeqs
    });else if (path) {
      this.index = new _tbi.default({
        filehandle: new _genericFilehandle.LocalFile("".concat(path, ".tbi")),
        renameRefSeqs: renameRefSeqs
      });
    } else {
      throw new TypeError('must provide one of tbiFilehandle, tbiPath, csiFilehandle, or csiPath');
    }
    this.chunkSizeLimit = chunkSizeLimit;
    this.yieldLimit = yieldLimit;
    this.renameRefSeq = renameRefSeqs;
    this.chunkCache = new _abortablePromiseCache.default({
      cache: new _quickLru.default({
        maxSize: Math.floor(chunkCacheSize / (1 << 16))
      }),
      fill: this.readChunk.bind(this)
    });
  }
  /**
   * @param {string} refName name of the reference sequence
   * @param {number} start start of the region (in 0-based half-open coordinates)
   * @param {number} end end of the region (in 0-based half-open coordinates)
   * @param {function|object} lineCallback callback called for each line in the region. can also pass a object param containing obj.lineCallback, obj.signal, etc
   * @returns {Promise} resolved when the whole read is finished, rejected on error
   */


  (0, _createClass2.default)(TabixIndexedFile, [{
    key: "getLines",
    value: function () {
      var _getLines = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(refName, start, end, opts) {
        var signal, options, callback, metadata, chunks, i, size, linesSinceLastYield, chunkNum, previousStartCoordinate, c, _yield$this$chunkCach, buffer, cpositions, dpositions, lines, blockStart, pos, _i, line, _this$checkLine, startCoordinate, overlaps;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = {};

                if (!(typeof opts === 'undefined')) {
                  _context.next = 3;
                  break;
                }

                throw new TypeError('line callback must be provided');

              case 3:
                if (typeof opts === 'function') callback = opts;else {
                  options = opts;
                  callback = opts.lineCallback;
                }

                if (!(refName === undefined)) {
                  _context.next = 6;
                  break;
                }

                throw new TypeError('must provide a reference sequence name');

              case 6:
                if (callback) {
                  _context.next = 8;
                  break;
                }

                throw new TypeError('line callback must be provided');

              case 8:
                _context.next = 10;
                return this.index.getMetadata(options);

              case 10:
                metadata = _context.sent;
                (0, _util.checkAbortSignal)(signal);

                if (!start) {
                  start = 0;
                }

                if (!end) {
                  end = metadata.maxRefLength;
                }

                if (start <= end) {
                  _context.next = 16;
                  break;
                }

                throw new TypeError('invalid start and end coordinates. start must be less than or equal to end');

              case 16:
                if (!(start === end)) {
                  _context.next = 18;
                  break;
                }

                return _context.abrupt("return");

              case 18:
                _context.next = 20;
                return this.index.blocksForRange(refName, start, end, options);

              case 20:
                chunks = _context.sent;
                (0, _util.checkAbortSignal)(signal); // check the chunks for any that are over the size limit.  if
                // any are, don't fetch any of them

                i = 0;

              case 23:
                if (!(i < chunks.length)) {
                  _context.next = 30;
                  break;
                }

                size = chunks[i].fetchedSize();

                if (!(size > this.chunkSizeLimit)) {
                  _context.next = 27;
                  break;
                }

                throw new Error("Too much data. Chunk size ".concat(size.toLocaleString(), " bytes exceeds chunkSizeLimit of ").concat(this.chunkSizeLimit.toLocaleString(), "."));

              case 27:
                i += 1;
                _context.next = 23;
                break;

              case 30:
                // now go through each chunk and parse and filter the lines out of it
                linesSinceLastYield = 0;
                chunkNum = 0;

              case 32:
                if (!(chunkNum < chunks.length)) {
                  _context.next = 73;
                  break;
                }

                previousStartCoordinate = void 0;
                c = chunks[chunkNum];
                _context.next = 37;
                return this.chunkCache.get(c.toString(), c, signal);

              case 37:
                _yield$this$chunkCach = _context.sent;
                buffer = _yield$this$chunkCach.buffer;
                cpositions = _yield$this$chunkCach.cpositions;
                dpositions = _yield$this$chunkCach.dpositions;
                lines = buffer.toString().split('\n');
                lines.pop();
                (0, _util.checkAbortSignal)(signal);
                blockStart = c.minv.dataPosition;
                pos = void 0;
                _i = 0;

              case 47:
                if (!(_i < lines.length)) {
                  _context.next = 70;
                  break;
                }

                line = lines[_i];

                for (pos = 0; blockStart >= dpositions[pos]; pos += 1) {
                  ;
                } // filter the line for whether it is within the requested range


                _this$checkLine = this.checkLine(metadata, refName, start, end, line), startCoordinate = _this$checkLine.startCoordinate, overlaps = _this$checkLine.overlaps; // do a small check just to make sure that the lines are really sorted by start coordinate

                if (!(previousStartCoordinate !== undefined && startCoordinate !== undefined && previousStartCoordinate > startCoordinate)) {
                  _context.next = 53;
                  break;
                }

                throw new Error("Lines not sorted by start coordinate (".concat(previousStartCoordinate, " > ").concat(startCoordinate, "), this file is not usable with Tabix."));

              case 53:
                previousStartCoordinate = startCoordinate;

                if (!overlaps) {
                  _context.next = 58;
                  break;
                }

                callback(line.trim(), // cpositions[pos] refers to actual file offset of a bgzip block boundaries
                //
                // we multiply by (1 <<8) in order to make sure each block has a "unique"
                // address space so that data in that block could never overlap
                //
                // then the blockStart-dpositions is an uncompressed file offset from
                // that bgzip block boundary, and since the cpositions are multiplied by
                // (1 << 8) these uncompressed offsets get a unique space
                cpositions[pos] * (1 << 8) + (blockStart - dpositions[pos]));
                _context.next = 60;
                break;

              case 58:
                if (!(startCoordinate !== undefined && startCoordinate >= end)) {
                  _context.next = 60;
                  break;
                }

                return _context.abrupt("return");

              case 60:
                blockStart += line.length + 1; // yield if we have emitted beyond the yield limit

                linesSinceLastYield += 1;

                if (!(linesSinceLastYield >= this.yieldLimit)) {
                  _context.next = 67;
                  break;
                }

                _context.next = 65;
                return timeout(1);

              case 65:
                (0, _util.checkAbortSignal)(signal);
                linesSinceLastYield = 0;

              case 67:
                _i += 1;
                _context.next = 47;
                break;

              case 70:
                chunkNum += 1;
                _context.next = 32;
                break;

              case 73:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getLines(_x, _x2, _x3, _x4) {
        return _getLines.apply(this, arguments);
      }

      return getLines;
    }()
  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var opts,
            _args2 = arguments;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                opts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                return _context2.abrupt("return", this.index.getMetadata(opts));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getMetadata() {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
    /**
     * get a buffer containing the "header" region of
     * the file, which are the bytes up to the first
     * non-meta line
     *
     * @returns {Promise} for a buffer
     */

  }, {
    key: "getHeaderBuffer",
    value: function () {
      var _getHeaderBuffer = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        var opts,
            _yield$this$getMetada,
            firstDataLine,
            metaChar,
            maxBlockSize,
            maxFetch,
            bytes,
            lastNewline,
            newlineByte,
            metaByte,
            i,
            _args3 = arguments;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                _context3.next = 3;
                return this.getMetadata(opts);

              case 3:
                _yield$this$getMetada = _context3.sent;
                firstDataLine = _yield$this$getMetada.firstDataLine;
                metaChar = _yield$this$getMetada.metaChar;
                maxBlockSize = _yield$this$getMetada.maxBlockSize;
                (0, _util.checkAbortSignal)(opts.signal);
                maxFetch = firstDataLine && firstDataLine.blockPosition ? firstDataLine.blockPosition + maxBlockSize : maxBlockSize; // TODO: what if we don't have a firstDataLine, and the header
                // actually takes up more than one block? this case is not covered here

                _context3.next = 11;
                return this._readRegion(0, maxFetch, opts);

              case 11:
                bytes = _context3.sent;
                (0, _util.checkAbortSignal)(opts.signal);
                _context3.prev = 13;
                _context3.next = 16;
                return (0, _bgzfFilehandle.unzip)(bytes);

              case 16:
                bytes = _context3.sent;
                _context3.next = 23;
                break;

              case 19:
                _context3.prev = 19;
                _context3.t0 = _context3["catch"](13);
                console.error(_context3.t0);
                throw new Error("error decompressing block ".concat(_context3.t0.code, " at 0 (length ").concat(maxFetch, ") ").concat(_context3.t0));

              case 23:
                if (!metaChar) {
                  _context3.next = 36;
                  break;
                }

                // trim backward from the end
                lastNewline = -1;
                newlineByte = '\n'.charCodeAt(0);
                metaByte = metaChar.charCodeAt(0);
                i = 0;

              case 28:
                if (!(i < bytes.length)) {
                  _context3.next = 35;
                  break;
                }

                if (!(i === lastNewline + 1 && bytes[i] !== metaByte)) {
                  _context3.next = 31;
                  break;
                }

                return _context3.abrupt("break", 35);

              case 31:
                if (bytes[i] === newlineByte) lastNewline = i;

              case 32:
                i += 1;
                _context3.next = 28;
                break;

              case 35:
                bytes = bytes.slice(0, lastNewline + 1);

              case 36:
                return _context3.abrupt("return", bytes);

              case 37:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[13, 19]]);
      }));

      function getHeaderBuffer() {
        return _getHeaderBuffer.apply(this, arguments);
      }

      return getHeaderBuffer;
    }()
    /**
     * get a string containing the "header" region of the
     * file, is the portion up to the first non-meta line
     *
     * @returns {Promise} for a string
     */

  }, {
    key: "getHeader",
    value: function () {
      var _getHeader = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
        var opts,
            bytes,
            _args4 = arguments;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                opts = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                _context4.next = 3;
                return this.getHeaderBuffer(opts);

              case 3:
                bytes = _context4.sent;
                (0, _util.checkAbortSignal)(opts.signal);
                return _context4.abrupt("return", bytes.toString('utf8'));

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getHeader() {
        return _getHeader.apply(this, arguments);
      }

      return getHeader;
    }()
    /**
     * get an array of reference sequence names, in the order in which
     * they occur in the file.
     *
     * reference sequence renaming is not applied to these names.
     *
     * @returns {Promise} for an array of string sequence names
     */

  }, {
    key: "getReferenceSequenceNames",
    value: function () {
      var _getReferenceSequenceNames = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
        var opts,
            metadata,
            _args5 = arguments;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                opts = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};
                _context5.next = 3;
                return this.getMetadata(opts);

              case 3:
                metadata = _context5.sent;
                return _context5.abrupt("return", metadata.refIdToName);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getReferenceSequenceNames() {
        return _getReferenceSequenceNames.apply(this, arguments);
      }

      return getReferenceSequenceNames;
    }()
    /**
     * @param {object} metadata metadata object from the parsed index,
     * containing columnNumbers, metaChar, and format
     * @param {string} regionRefName
     * @param {number} regionStart region start coordinate (0-based-half-open)
     * @param {number} regionEnd region end coordinate (0-based-half-open)
     * @param {array[string]} line
     * @returns {object} like `{startCoordinate, overlaps}`. overlaps is boolean,
     * true if line is a data line that overlaps the given region
     */

  }, {
    key: "checkLine",
    value: function checkLine(_ref2, regionRefName, regionStart, regionEnd, line) {
      var columnNumbers = _ref2.columnNumbers,
          metaChar = _ref2.metaChar,
          coordinateType = _ref2.coordinateType,
          format = _ref2.format;

      // skip meta lines
      if (line.charAt(0) === metaChar) {
        return {
          overlaps: false
        };
      } // check ref/start/end using column metadata from index


      var ref = columnNumbers.ref,
          start = columnNumbers.start,
          end = columnNumbers.end;
      if (!ref) ref = 0;
      if (!start) start = 0;
      if (!end) end = 0;
      if (format === 'VCF') end = 8;
      var maxColumn = Math.max(ref, start, end); // this code is kind of complex, but it is fairly fast.
      // basically, we want to avoid doing a split, because if the lines are really long
      // that could lead to us allocating a bunch of extra memory, which is slow

      var currentColumnNumber = 1; // cols are numbered starting at 1 in the index metadata

      var currentColumnStart = 0;
      var refSeq = '';
      var startCoordinate = -Infinity;

      for (var i = 0; i < line.length + 1; i += 1) {
        if (line[i] === '\t' || i === line.length) {
          if (currentColumnNumber === ref) {
            if (this.renameRefSeq(line.slice(currentColumnStart, i)) !== regionRefName) {
              return {
                overlaps: false
              };
            }
          } else if (currentColumnNumber === start) {
            startCoordinate = (0, _parseInt2.default)(line.slice(currentColumnStart, i), 10); // we convert to 0-based-half-open

            if (coordinateType === '1-based-closed') {
              startCoordinate -= 1;
            }

            if (startCoordinate >= regionEnd) {
              return {
                startCoordinate: startCoordinate,
                overlaps: false
              };
            }

            if (end === 0 || end === start) {
              // if we have no end, we assume the feature is 1 bp long
              if (startCoordinate + 1 <= regionStart) {
                return {
                  startCoordinate: startCoordinate,
                  overlaps: false
                };
              }
            }
          } else if (format === 'VCF' && currentColumnNumber === 4) {
            refSeq = line.slice(currentColumnStart, i);
          } else if (currentColumnNumber === end) {
            var endCoordinate = void 0; // this will never match if there is no end column

            if (format === 'VCF') {
              endCoordinate = this._getVcfEnd(startCoordinate, refSeq, line.slice(currentColumnStart, i));
            } else {
              endCoordinate = (0, _parseInt2.default)(line.slice(currentColumnStart, i), 10);
            }

            if (endCoordinate <= regionStart) {
              return {
                overlaps: false
              };
            }
          }

          currentColumnStart = i + 1;
          currentColumnNumber += 1;

          if (currentColumnNumber > maxColumn) {
            break;
          }
        }
      }

      return {
        startCoordinate: startCoordinate,
        overlaps: true
      };
    }
  }, {
    key: "_getVcfEnd",
    value: function _getVcfEnd(startCoordinate, refSeq, info) {
      var endCoordinate = startCoordinate + refSeq.length; // ignore TRA features as they specify CHR2 and END
      // as being on a different chromosome
      // if CHR2 is on the same chromosome, still ignore it
      // because there should be another pairwise feature
      // at the end of this one

      var isTRA = info.indexOf('SVTYPE=TRA') !== -1;

      if (info[0] !== '.' && !isTRA) {
        var prevChar = ';';

        for (var j = 0; j < info.length; j += 1) {
          if (prevChar === ';' && info.slice(j, j + 4) === 'END=') {
            var valueEnd = info.indexOf(';', j);
            if (valueEnd === -1) valueEnd = info.length;
            endCoordinate = (0, _parseInt2.default)(info.slice(j + 4, valueEnd), 10);
            break;
          }

          prevChar = info[j];
        }
      } else if (isTRA) {
        return startCoordinate + 1;
      }

      return endCoordinate;
    }
    /**
     * return the approximate number of data lines in the given reference sequence
     * @param {string} refSeq reference sequence name
     * @returns {Promise} for number of data lines present on that reference sequence
     */

  }, {
    key: "lineCount",
    value: function () {
      var _lineCount = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(refName) {
        var opts,
            _args6 = arguments;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
                return _context6.abrupt("return", this.index.lineCount(refName, opts));

              case 2:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function lineCount(_x5) {
        return _lineCount.apply(this, arguments);
      }

      return lineCount;
    }()
  }, {
    key: "_readRegion",
    value: function () {
      var _readRegion2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(position, compressedSize) {
        var opts,
            _yield$this$filehandl,
            bytesRead,
            buffer,
            _args7 = arguments;

        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                opts = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : {};
                _context7.next = 3;
                return this.filehandle.read(Buffer.alloc(compressedSize), 0, compressedSize, position, opts);

              case 3:
                _yield$this$filehandl = _context7.sent;
                bytesRead = _yield$this$filehandl.bytesRead;
                buffer = _yield$this$filehandl.buffer;
                return _context7.abrupt("return", bytesRead < compressedSize ? buffer.slice(0, bytesRead) : buffer);

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _readRegion(_x6, _x7) {
        return _readRegion2.apply(this, arguments);
      }

      return _readRegion;
    }()
    /**
     * read and uncompress the data in a chunk (composed of one or more
     * contiguous bgzip blocks) of the file
     * @param {Chunk} chunk
     * @returns {Promise} for a string chunk of the file
     */

  }, {
    key: "readChunk",
    value: function () {
      var _readChunk = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(chunk) {
        var opts,
            compressedData,
            _args8 = arguments;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
                _context8.next = 3;
                return this._readRegion(chunk.minv.blockPosition, chunk.fetchedSize(), opts);

              case 3:
                compressedData = _context8.sent;
                _context8.prev = 4;
                return _context8.abrupt("return", (0, _bgzfFilehandle.unzipChunkSlice)(compressedData, chunk));

              case 8:
                _context8.prev = 8;
                _context8.t0 = _context8["catch"](4);
                throw new Error("error decompressing chunk ".concat(chunk.toString(), " ").concat(_context8.t0));

              case 11:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[4, 8]]);
      }));

      function readChunk(_x8) {
        return _readChunk.apply(this, arguments);
      }

      return readChunk;
    }()
  }]);
  return TabixIndexedFile;
}();

exports.default = TabixIndexedFile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90YWJpeEluZGV4ZWRGaWxlLnRzIl0sIm5hbWVzIjpbInRpbWVvdXQiLCJ0aW1lIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJUYWJpeEluZGV4ZWRGaWxlIiwicGF0aCIsImZpbGVoYW5kbGUiLCJ0YmlQYXRoIiwidGJpRmlsZWhhbmRsZSIsImNzaVBhdGgiLCJjc2lGaWxlaGFuZGxlIiwiY2h1bmtTaXplTGltaXQiLCJ5aWVsZExpbWl0IiwicmVuYW1lUmVmU2VxcyIsIm4iLCJjaHVua0NhY2hlU2l6ZSIsIkxvY2FsRmlsZSIsIlR5cGVFcnJvciIsImluZGV4IiwiVEJJIiwiQ1NJIiwicmVuYW1lUmVmU2VxIiwiY2h1bmtDYWNoZSIsIkFib3J0YWJsZVByb21pc2VDYWNoZSIsImNhY2hlIiwiTFJVIiwibWF4U2l6ZSIsIk1hdGgiLCJmbG9vciIsImZpbGwiLCJyZWFkQ2h1bmsiLCJiaW5kIiwicmVmTmFtZSIsInN0YXJ0IiwiZW5kIiwib3B0cyIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImxpbmVDYWxsYmFjayIsInVuZGVmaW5lZCIsImdldE1ldGFkYXRhIiwibWV0YWRhdGEiLCJzaWduYWwiLCJtYXhSZWZMZW5ndGgiLCJibG9ja3NGb3JSYW5nZSIsImNodW5rcyIsImkiLCJsZW5ndGgiLCJzaXplIiwiZmV0Y2hlZFNpemUiLCJFcnJvciIsInRvTG9jYWxlU3RyaW5nIiwibGluZXNTaW5jZUxhc3RZaWVsZCIsImNodW5rTnVtIiwicHJldmlvdXNTdGFydENvb3JkaW5hdGUiLCJjIiwiZ2V0IiwidG9TdHJpbmciLCJidWZmZXIiLCJjcG9zaXRpb25zIiwiZHBvc2l0aW9ucyIsImxpbmVzIiwic3BsaXQiLCJwb3AiLCJibG9ja1N0YXJ0IiwibWludiIsImRhdGFQb3NpdGlvbiIsInBvcyIsImxpbmUiLCJjaGVja0xpbmUiLCJzdGFydENvb3JkaW5hdGUiLCJvdmVybGFwcyIsInRyaW0iLCJmaXJzdERhdGFMaW5lIiwibWV0YUNoYXIiLCJtYXhCbG9ja1NpemUiLCJtYXhGZXRjaCIsImJsb2NrUG9zaXRpb24iLCJfcmVhZFJlZ2lvbiIsImJ5dGVzIiwiY29uc29sZSIsImVycm9yIiwiY29kZSIsImxhc3ROZXdsaW5lIiwibmV3bGluZUJ5dGUiLCJjaGFyQ29kZUF0IiwibWV0YUJ5dGUiLCJzbGljZSIsImdldEhlYWRlckJ1ZmZlciIsInJlZklkVG9OYW1lIiwicmVnaW9uUmVmTmFtZSIsInJlZ2lvblN0YXJ0IiwicmVnaW9uRW5kIiwiY29sdW1uTnVtYmVycyIsImNvb3JkaW5hdGVUeXBlIiwiZm9ybWF0IiwiY2hhckF0IiwicmVmIiwibWF4Q29sdW1uIiwibWF4IiwiY3VycmVudENvbHVtbk51bWJlciIsImN1cnJlbnRDb2x1bW5TdGFydCIsInJlZlNlcSIsIkluZmluaXR5IiwiZW5kQ29vcmRpbmF0ZSIsIl9nZXRWY2ZFbmQiLCJpbmZvIiwiaXNUUkEiLCJpbmRleE9mIiwicHJldkNoYXIiLCJqIiwidmFsdWVFbmQiLCJsaW5lQ291bnQiLCJwb3NpdGlvbiIsImNvbXByZXNzZWRTaXplIiwicmVhZCIsIkJ1ZmZlciIsImFsbG9jIiwiYnl0ZXNSZWFkIiwiY2h1bmsiLCJjb21wcmVzc2VkRGF0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFHQTs7QUFDQTs7QUFFQSxTQUFTQSxPQUFULENBQWlCQyxJQUFqQixFQUErQjtBQUM3QixTQUFPLHFCQUFZLFVBQUFDLE9BQU8sRUFBSTtBQUM1QkMsSUFBQUEsVUFBVSxDQUFDRCxPQUFELEVBQVVELElBQVYsQ0FBVjtBQUNELEdBRk0sQ0FBUDtBQUdEOztJQUVvQkcsZ0I7QUFPbkI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxrQ0FzQkc7QUFBQSxRQXJCREMsSUFxQkMsUUFyQkRBLElBcUJDO0FBQUEsUUFwQkRDLFVBb0JDLFFBcEJEQSxVQW9CQztBQUFBLFFBbkJEQyxPQW1CQyxRQW5CREEsT0FtQkM7QUFBQSxRQWxC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ZXNDb250ZW50IjpbImltcG9ydCBBYm9ydGFibGVQcm9taXNlQ2FjaGUgZnJvbSAnYWJvcnRhYmxlLXByb21pc2UtY2FjaGUnXG5pbXBvcnQgTFJVIGZyb20gJ3F1aWNrLWxydSdcbmltcG9ydCB7IEdlbmVyaWNGaWxlaGFuZGxlLCBMb2NhbEZpbGUgfSBmcm9tICdnZW5lcmljLWZpbGVoYW5kbGUnXG5pbXBvcnQgeyB1bnppcCwgdW56aXBDaHVua1NsaWNlIH0gZnJvbSAnQGdtb2QvYmd6Zi1maWxlaGFuZGxlJ1xuXG5pbXBvcnQgeyBjaGVja0Fib3J0U2lnbmFsIH0gZnJvbSAnLi91dGlsJ1xuaW1wb3J0IEluZGV4RmlsZSwgeyBPcHRpb25zIH0gZnJvbSAnLi9pbmRleEZpbGUnXG5pbXBvcnQgQ2h1bmsgZnJvbSAnLi9jaHVuaydcbmltcG9ydCBUQkkgZnJvbSAnLi90YmknXG5pbXBvcnQgQ1NJIGZyb20gJy4vY3NpJ1xuXG5mdW5jdGlvbiB0aW1lb3V0KHRpbWU6IG51bWJlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lKVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJpeEluZGV4ZWRGaWxlIHtcbiAgcHJpdmF0ZSBmaWxlaGFuZGxlOiBHZW5lcmljRmlsZWhhbmRsZVxuICBwcml2YXRlIGluZGV4OiBJbmRleEZpbGVcbiAgcHJpdmF0ZSBjaHVua1NpemVMaW1pdDogbnVtYmVyXG4gIHByaXZhdGUgcmVuYW1lUmVmU2VxOiAobjogc3RyaW5nKSA9PiBzdHJpbmdcbiAgcHJpdmF0ZSB5aWVsZExpbWl0OiBudW1iZXJcbiAgcHJpdmF0ZSBjaHVua0NhY2hlOiBhbnlcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5wYXRoXVxuICAgKiBAcGFyYW0ge2ZpbGVoYW5kbGV9IFthcmdzLmZpbGVoYW5kbGVdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy50YmlQYXRoXVxuICAgKiBAcGFyYW0ge2ZpbGVoYW5kbGV9IFthcmdzLnRiaUZpbGVoYW5kbGVdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jc2lQYXRoXVxuICAgKiBAcGFyYW0ge2ZpbGVoYW5kbGV9IFthcmdzLmNzaUZpbGVoYW5kbGVdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5jaHVua1NpemVMaW1pdF0gbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gZmV0Y2ggaW4gYSBzaW5nbGUgYGdldExpbmVzYCBjYWxsLlxuICAgKiBkZWZhdWx0IDJNaUJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLnlpZWxkTGltaXRdIG1heGltdW0gbnVtYmVyIG9mIGxpbmVzIHRvIHBhcnNlIHdpdGhvdXQgeWllbGRpbmcuXG4gICAqIHRoaXMgYXZvaWRzIGhhdmluZyBhIGxhcmdlIHJlYWQgcHJldmVudCBhbnkgb3RoZXIgd29yayBnZXR0aW5nIGRvbmUgb24gdGhlIHRocmVhZC4gIGRlZmF1bHQgMzAwIGxpbmVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbYXJncy5yZW5hbWVSZWZTZXFzXSBvcHRpb25hbCBmdW5jdGlvbiB3aXRoIHNpZyBgc3RyaW5nID0+IHN0cmluZ2AgdG8gdHJhbnNmb3JtXG4gICAqIHJlZmVyZW5jZSBzZXF1ZW5jZSBuYW1lcyBmb3IgdGhlIHB1cnBvc2Ugb2YgaW5kZXhpbmcgYW5kIHF1ZXJ5aW5nLiBub3RlIHRoYXQgdGhlIGRhdGEgdGhhdCBpcyByZXR1cm5lZCBpc1xuICAgKiBub3QgYWx0ZXJlZCwganVzdCB0aGUgbmFtZXMgb2YgdGhlIHJlZmVyZW5jZSBzZXF1ZW5jZXMgdGhhdCBhcmUgdXNlZCBmb3IgcXVlcnlpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5jaHVua0NhY2hlU2l6ZV0gbWF4aW11bSBzaXplIGluIGJ5dGVzIG9mIHRoZSBjaHVuayBjYWNoZS4gZGVmYXVsdCA1TUJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmJsb2NrQ2FjaGVTaXplXSBtYXhpbXVtIHNpemUgaW4gYnl0ZXMgb2YgdGhlIGJsb2NrIGNhY2hlLiBkZWZhdWx0IDVNQlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhdGgsXG4gICAgZmlsZWhhbmRsZSxcbiAgICB0YmlQYXRoLFxuICAgIHRiaUZpbGVoYW5kbGUsXG4gICAgY3NpUGF0aCxcbiAgICBjc2lGaWxlaGFuZGxlLFxuICAgIGNodW5rU2l6ZUxpbWl0ID0gMjAwMDAwMCxcbiAgICB5aWVsZExpbWl0ID0gMzAwLFxuICAgIHJlbmFtZVJlZlNlcXMgPSBuID0+IG4sXG4gICAgY2h1bmtDYWNoZVNpemUgPSA1ICogMiAqKiAyMCxcbiAgfToge1xuICAgIHBhdGg/OiBzdHJpbmdcbiAgICBmaWxlaGFuZGxlPzogR2VuZXJpY0ZpbGVoYW5kbGVcbiAgICB0YmlQYXRoPzogc3RyaW5nXG4gICAgdGJpRmlsZWhhbmRsZT86IEdlbmVyaWNGaWxlaGFuZGxlXG4gICAgY3NpUGF0aD86IHN0cmluZ1xuICAgIGNzaUZpbGVoYW5kbGU/OiBHZW5lcmljRmlsZWhhbmRsZVxuICAgIGNodW5rU2l6ZUxpbWl0PzogbnVtYmVyXG4gICAgeWllbGRMaW1pdD86IG51bWJlclxuICAgIHJlbmFtZVJlZlNlcXM/OiAobjogc3RyaW5nKSA9PiBzdHJpbmdcbiAgICBjaHVua0NhY2hlU2l6ZT86IG51bWJlclxuICB9KSB7XG4gICAgaWYgKGZpbGVoYW5kbGUpIHRoaXMuZmlsZWhhbmRsZSA9IGZpbGVoYW5kbGVcbiAgICBlbHNlIGlmIChwYXRoKSB0aGlzLmZpbGVoYW5kbGUgPSBuZXcgTG9jYWxGaWxlKHBhdGgpXG4gICAgZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHByb3ZpZGUgZWl0aGVyIGZpbGVoYW5kbGUgb3IgcGF0aCcpXG5cbiAgICBpZiAodGJpRmlsZWhhbmRsZSlcbiAgICAgIHRoaXMuaW5kZXggPSBuZXcgVEJJKHtcbiAgICAgICAgZmlsZWhhbmRsZTogdGJpRmlsZWhhbmRsZSxcbiAgICAgICAgcmVuYW1lUmVmU2VxcyxcbiAgICAgIH0pXG4gICAgZWxzZSBpZiAoY3NpRmlsZWhhbmRsZSlcbiAgICAgIHRoaXMuaW5kZXggPSBuZXcgQ1NJKHtcbiAgICAgICAgZmlsZWhhbmRsZTogY3NpRmlsZWhhbmRsZSxcbiAgICAgICAgcmVuYW1lUmVmU2VxcyxcbiAgICAgIH0pXG4gICAgZWxzZSBpZiAodGJpUGF0aClcbiAgICAgIHRoaXMuaW5kZXggPSBuZXcgVEJJKHtcbiAgICAgICAgZmlsZWhhbmRsZTogbmV3IExvY2FsRmlsZSh0YmlQYXRoKSxcbiAgICAgICAgcmVuYW1lUmVmU2VxcyxcbiAgICAgIH0pXG4gICAgZWxzZSBpZiAoY3NpUGF0aClcbiAgICAgIHRoaXMuaW5kZXggPSBuZXcgQ1NJKHtcbiAgICAgICAgZmlsZWhhbmRsZTogbmV3IExvY2FsRmlsZShjc2lQYXRoKSxcbiAgICAgICAgcmVuYW1lUmVmU2VxcyxcbiAgICAgIH0pXG4gICAgZWxzZSBpZiAocGF0aCkge1xuICAgICAgdGhpcy5pbmRleCA9IG5ldyBUQkkoe1xuICAgICAgICBmaWxlaGFuZGxlOiBuZXcgTG9jYWxGaWxlKGAke3BhdGh9LnRiaWApLFxuICAgICAgICByZW5hbWVSZWZTZXFzLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ211c3QgcHJvdmlkZSBvbmUgb2YgdGJpRmlsZWhhbmRsZSwgdGJpUGF0aCwgY3NpRmlsZWhhbmRsZSwgb3IgY3NpUGF0aCcsXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5jaHVua1NpemVMaW1pdCA9IGNodW5rU2l6ZUxpbWl0XG4gICAgdGhpcy55aWVsZExpbWl0ID0geWllbGRMaW1pdFxuICAgIHRoaXMucmVuYW1lUmVmU2VxID0gcmVuYW1lUmVmU2Vxc1xuICAgIHRoaXMuY2h1bmtDYWNoZSA9IG5ldyBBYm9ydGFibGVQcm9taXNlQ2FjaGUoe1xuICAgICAgY2FjaGU6IG5ldyBMUlUoe1xuICAgICAgICBtYXhTaXplOiBNYXRoLmZsb29yKGNodW5rQ2FjaGVTaXplIC8gKDEgPDwgMTYpKSxcbiAgICAgIH0pLFxuXG4gICAgICBmaWxsOiB0aGlzLnJlYWRDaHVuay5iaW5kKHRoaXMpLFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZk5hbWUgbmFtZSBvZiB0aGUgcmVmZXJlbmNlIHNlcXVlbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBzdGFydCBvZiB0aGUgcmVnaW9uIChpbiAwLWJhc2VkIGhhbGYtb3BlbiBjb29yZGluYXRlcylcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBlbmQgb2YgdGhlIHJlZ2lvbiAoaW4gMC1iYXNlZCBoYWxmLW9wZW4gY29vcmRpbmF0ZXMpXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0fSBsaW5lQ2FsbGJhY2sgY2FsbGJhY2sgY2FsbGVkIGZvciBlYWNoIGxpbmUgaW4gdGhlIHJlZ2lvbi4gY2FuIGFsc28gcGFzcyBhIG9iamVjdCBwYXJhbSBjb250YWluaW5nIG9iai5saW5lQ2FsbGJhY2ssIG9iai5zaWduYWwsIGV0Y1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVzb2x2ZWQgd2hlbiB0aGUgd2hvbGUgcmVhZCBpcyBmaW5pc2hlZCwgcmVqZWN0ZWQgb24gZXJyb3JcbiAgICovXG4gIGFzeW5jIGdldExpbmVzKFxuICAgIHJlZk5hbWU6IHN0cmluZyxcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIGVuZDogbnVtYmVyLFxuICAgIG9wdHM6IHsgc2lnbmFsPzogQWJvcnRTaWduYWw7IGxpbmVDYWxsYmFjazogRnVuY3Rpb24gfSB8IEZ1bmN0aW9uLFxuICApIHtcbiAgICBsZXQgc2lnbmFsOiBBYm9ydFNpZ25hbCB8IHVuZGVmaW5lZFxuICAgIGxldCBvcHRpb25zOiBPcHRpb25zID0ge31cbiAgICBsZXQgY2FsbGJhY2s6IEZ1bmN0aW9uXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAndW5kZWZpbmVkJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpbmUgY2FsbGJhY2sgbXVzdCBiZSBwcm92aWRlZCcpXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjayA9IG9wdHNcbiAgICBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRzXG4gICAgICBjYWxsYmFjayA9IG9wdHMubGluZUNhbGxiYWNrXG4gICAgfVxuICAgIGlmIChyZWZOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3QgcHJvdmlkZSBhIHJlZmVyZW5jZSBzZXF1ZW5jZSBuYW1lJylcbiAgICB9XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGluZSBjYWxsYmFjayBtdXN0IGJlIHByb3ZpZGVkJylcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuaW5kZXguZ2V0TWV0YWRhdGEob3B0aW9ucylcbiAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbClcbiAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICBzdGFydCA9IDBcbiAgICB9XG4gICAgaWYgKCFlbmQpIHtcbiAgICAgIGVuZCA9IG1ldGFkYXRhLm1heFJlZkxlbmd0aFxuICAgIH1cbiAgICBpZiAoIShzdGFydCA8PSBlbmQpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgc3RhcnQgYW5kIGVuZCBjb29yZGluYXRlcy4gc3RhcnQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gZW5kJyxcbiAgICAgIClcbiAgICBpZiAoc3RhcnQgPT09IGVuZCkgcmV0dXJuXG5cbiAgICBjb25zdCBjaHVua3MgPSBhd2FpdCB0aGlzLmluZGV4LmJsb2Nrc0ZvclJhbmdlKHJlZk5hbWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMpXG4gICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpXG5cbiAgICAvLyBjaGVjayB0aGUgY2h1bmtzIGZvciBhbnkgdGhhdCBhcmUgb3ZlciB0aGUgc2l6ZSBsaW1pdC4gIGlmXG4gICAgLy8gYW55IGFyZSwgZG9uJ3QgZmV0Y2ggYW55IG9mIHRoZW1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IGNodW5rc1tpXS5mZXRjaGVkU2l6ZSgpXG4gICAgICBpZiAoc2l6ZSA+IHRoaXMuY2h1bmtTaXplTGltaXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBUb28gbXVjaCBkYXRhLiBDaHVuayBzaXplICR7c2l6ZS50b0xvY2FsZVN0cmluZygpfSBieXRlcyBleGNlZWRzIGNodW5rU2l6ZUxpbWl0IG9mICR7dGhpcy5jaHVua1NpemVMaW1pdC50b0xvY2FsZVN0cmluZygpfS5gLFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm93IGdvIHRocm91Z2ggZWFjaCBjaHVuayBhbmQgcGFyc2UgYW5kIGZpbHRlciB0aGUgbGluZXMgb3V0IG9mIGl0XG4gICAgbGV0IGxpbmVzU2luY2VMYXN0WWllbGQgPSAwXG4gICAgZm9yIChsZXQgY2h1bmtOdW0gPSAwOyBjaHVua051bSA8IGNodW5rcy5sZW5ndGg7IGNodW5rTnVtICs9IDEpIHtcbiAgICAgIGxldCBwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZTogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgICBjb25zdCBjID0gY2h1bmtzW2NodW5rTnVtXVxuICAgICAgY29uc3QgeyBidWZmZXIsIGNwb3NpdGlvbnMsIGRwb3NpdGlvbnMgfSA9IGF3YWl0IHRoaXMuY2h1bmtDYWNoZS5nZXQoXG4gICAgICAgIGMudG9TdHJpbmcoKSxcbiAgICAgICAgYyxcbiAgICAgICAgc2lnbmFsLFxuICAgICAgKVxuICAgICAgY29uc3QgbGluZXMgPSBidWZmZXIudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylcbiAgICAgIGxpbmVzLnBvcCgpXG4gICAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbClcbiAgICAgIGxldCBibG9ja1N0YXJ0ID0gYy5taW52LmRhdGFQb3NpdGlvblxuICAgICAgbGV0IHBvc1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXVxuXG4gICAgICAgIGZvciAocG9zID0gMDsgYmxvY2tTdGFydCA+PSBkcG9zaXRpb25zW3Bvc107IHBvcyArPSAxKTtcblxuICAgICAgICAvLyBmaWx0ZXIgdGhlIGxpbmUgZm9yIHdoZXRoZXIgaXQgaXMgd2l0aGluIHRoZSByZXF1ZXN0ZWQgcmFuZ2VcbiAgICAgICAgY29uc3QgeyBzdGFydENvb3JkaW5hdGUsIG92ZXJsYXBzIH0gPSB0aGlzLmNoZWNrTGluZShcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICByZWZOYW1lLFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgICBsaW5lLFxuICAgICAgICApXG5cbiAgICAgICAgLy8gZG8gYSBzbWFsbCBjaGVjayBqdXN0IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBsaW5lcyBhcmUgcmVhbGx5IHNvcnRlZCBieSBzdGFydCBjb29yZGluYXRlXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgc3RhcnRDb29yZGluYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZSA+IHN0YXJ0Q29vcmRpbmF0ZVxuICAgICAgICApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYExpbmVzIG5vdCBzb3J0ZWQgYnkgc3RhcnQgY29vcmRpbmF0ZSAoJHtwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZX0gPiAke3N0YXJ0Q29vcmRpbmF0ZX0pLCB0aGlzIGZpbGUgaXMgbm90IHVzYWJsZSB3aXRoIFRhYml4LmAsXG4gICAgICAgICAgKVxuICAgICAgICBwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZSA9IHN0YXJ0Q29vcmRpbmF0ZVxuXG4gICAgICAgIGlmIChvdmVybGFwcykge1xuICAgICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgICAgbGluZS50cmltKCksXG4gICAgICAgICAgICAvLyBjcG9zaXRpb25zW3Bvc10gcmVmZXJzIHRvIGFjdHVhbCBmaWxlIG9mZnNldCBvZiBhIGJnemlwIGJsb2NrIGJvdW5kYXJpZXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB3ZSBtdWx0aXBseSBieSAoMSA8PDgpIGluIG9yZGVyIHRvIG1ha2Ugc3VyZSBlYWNoIGJsb2NrIGhhcyBhIFwidW5pcXVlXCJcbiAgICAgICAgICAgIC8vIGFkZHJlc3Mgc3BhY2Ugc28gdGhhdCBkYXRhIGluIHRoYXQgYmxvY2sgY291bGQgbmV2ZXIgb3ZlcmxhcFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoZW4gdGhlIGJsb2NrU3RhcnQtZHBvc2l0aW9ucyBpcyBhbiB1bmNvbXByZXNzZWQgZmlsZSBvZmZzZXQgZnJvbVxuICAgICAgICAgICAgLy8gdGhhdCBiZ3ppcCBibG9jayBib3VuZGFyeSwgYW5kIHNpbmNlIHRoZSBjcG9zaXRpb25zIGFyZSBtdWx0aXBsaWVkIGJ5XG4gICAgICAgICAgICAvLyAoMSA8PCA4KSB0aGVzZSB1bmNvbXByZXNzZWQgb2Zmc2V0cyBnZXQgYSB1bmlxdWUgc3BhY2VcbiAgICAgICAgICAgIGNwb3NpdGlvbnNbcG9zXSAqICgxIDw8IDgpICsgKGJsb2NrU3RhcnQgLSBkcG9zaXRpb25zW3Bvc10pLFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydENvb3JkaW5hdGUgIT09IHVuZGVmaW5lZCAmJiBzdGFydENvb3JkaW5hdGUgPj0gZW5kKSB7XG4gICAgICAgICAgLy8gdGhlIGxpbmVzIHdlcmUgb3ZlcmxhcHBpbmcgdGhlIHJlZ2lvbiwgYnV0IG5vdyBoYXZlIHN0b3BwZWQsIHNvXG4gICAgICAgICAgLy8gd2UgbXVzdCBiZSBhdCB0aGUgZW5kIG9mIHRoZSByZWxldmFudCBkYXRhIGFuZCB3ZSBjYW4gc3RvcFxuICAgICAgICAgIC8vIHByb2Nlc3NpbmcgZGF0YSBub3dcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBibG9ja1N0YXJ0ICs9IGxpbmUubGVuZ3RoICsgMVxuXG4gICAgICAgIC8vIHlpZWxkIGlmIHdlIGhhdmUgZW1pdHRlZCBiZXlvbmQgdGhlIHlpZWxkIGxpbWl0XG4gICAgICAgIGxpbmVzU2luY2VMYXN0WWllbGQgKz0gMVxuICAgICAgICBpZiAobGluZXNTaW5jZUxhc3RZaWVsZCA+PSB0aGlzLnlpZWxkTGltaXQpIHtcbiAgICAgICAgICBhd2FpdCB0aW1lb3V0KDEpXG4gICAgICAgICAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpXG4gICAgICAgICAgbGluZXNTaW5jZUxhc3RZaWVsZCA9IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldE1ldGFkYXRhKG9wdHM6IE9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmluZGV4LmdldE1ldGFkYXRhKG9wdHMpXG4gIH1cblxuICAvKipcbiAgICogZ2V0IGEgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIFwiaGVhZGVyXCIgcmVnaW9uIG9mXG4gICAqIHRoZSBmaWxlLCB3aGljaCBhcmUgdGhlIGJ5dGVzIHVwIHRvIHRoZSBmaXJzdFxuICAgKiBub24tbWV0YSBsaW5lXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3IgYSBidWZmZXJcbiAgICovXG4gIGFzeW5jIGdldEhlYWRlckJ1ZmZlcihvcHRzOiBPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGZpcnN0RGF0YUxpbmUsIG1ldGFDaGFyLCBtYXhCbG9ja1NpemUgfSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEoXG4gICAgICBvcHRzLFxuICAgIClcbiAgICBjaGVja0Fib3J0U2lnbmFsKG9wdHMuc2lnbmFsKVxuICAgIGNvbnN0IG1heEZldGNoID1cbiAgICAgIGZpcnN0RGF0YUxpbmUgJiYgZmlyc3REYXRhTGluZS5ibG9ja1Bvc2l0aW9uXG4gICAgICAgID8gZmlyc3REYXRhTGluZS5ibG9ja1Bvc2l0aW9uICsgbWF4QmxvY2tTaXplXG4gICAgICAgIDogbWF4QmxvY2tTaXplXG4gICAgLy8gVE9ETzogd2hhdCBpZiB3ZSBkb24ndCBoYXZlIGEgZmlyc3REYXRhTGluZSwgYW5kIHRoZSBoZWFkZXJcbiAgICAvLyBhY3R1YWxseSB0YWtlcyB1cCBtb3JlIHRoYW4gb25lIGJsb2NrPyB0aGlzIGNhc2UgaXMgbm90IGNvdmVyZWQgaGVyZVxuXG4gICAgbGV0IGJ5dGVzID0gYXdhaXQgdGhpcy5fcmVhZFJlZ2lvbigwLCBtYXhGZXRjaCwgb3B0cylcbiAgICBjaGVja0Fib3J0U2lnbmFsKG9wdHMuc2lnbmFsKVxuICAgIHRyeSB7XG4gICAgICBieXRlcyA9IGF3YWl0IHVuemlwKGJ5dGVzKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGVycm9yIGRlY29tcHJlc3NpbmcgYmxvY2sgJHtlLmNvZGV9IGF0IDAgKGxlbmd0aCAke21heEZldGNofSkgJHtlfWAsXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gdHJpbSBvZmYgbGluZXMgYWZ0ZXIgdGhlIGxhc3Qgbm9uLW1ldGEgbGluZVxuICAgIGlmIChtZXRhQ2hhcikge1xuICAgICAgLy8gdHJpbSBiYWNrd2FyZCBmcm9tIHRoZSBlbmRcbiAgICAgIGxldCBsYXN0TmV3bGluZSA9IC0xXG4gICAgICBjb25zdCBuZXdsaW5lQnl0ZSA9ICdcXG4nLmNoYXJDb2RlQXQoMClcbiAgICAgIGNvbnN0IG1ldGFCeXRlID0gbWV0YUNoYXIuY2hhckNvZGVBdCgwKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoaSA9PT0gbGFzdE5ld2xpbmUgKyAxICYmIGJ5dGVzW2ldICE9PSBtZXRhQnl0ZSkgYnJlYWtcbiAgICAgICAgaWYgKGJ5dGVzW2ldID09PSBuZXdsaW5lQnl0ZSkgbGFzdE5ld2xpbmUgPSBpXG4gICAgICB9XG4gICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKDAsIGxhc3ROZXdsaW5lICsgMSlcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzXG4gIH1cblxuICAvKipcbiAgICogZ2V0IGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIFwiaGVhZGVyXCIgcmVnaW9uIG9mIHRoZVxuICAgKiBmaWxlLCBpcyB0aGUgcG9ydGlvbiB1cCB0byB0aGUgZmlyc3Qgbm9uLW1ldGEgbGluZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gZm9yIGEgc3RyaW5nXG4gICAqL1xuICBhc3luYyBnZXRIZWFkZXIob3B0czogT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhd2FpdCB0aGlzLmdldEhlYWRlckJ1ZmZlcihvcHRzKVxuICAgIGNoZWNrQWJvcnRTaWduYWwob3B0cy5zaWduYWwpXG4gICAgcmV0dXJuIGJ5dGVzLnRvU3RyaW5nKCd1dGY4JylcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgYW4gYXJyYXkgb2YgcmVmZXJlbmNlIHNlcXVlbmNlIG5hbWVzLCBpbiB0aGUgb3JkZXIgaW4gd2hpY2hcbiAgICogdGhleSBvY2N1ciBpbiB0aGUgZmlsZS5cbiAgICpcbiAgICogcmVmZXJlbmNlIHNlcXVlbmNlIHJlbmFtaW5nIGlzIG5vdCBhcHBsaWVkIHRvIHRoZXNlIG5hbWVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gZm9yIGFuIGFycmF5IG9mIHN0cmluZyBzZXF1ZW5jZSBuYW1lc1xuICAgKi9cbiAgYXN5bmMgZ2V0UmVmZXJlbmNlU2VxdWVuY2VOYW1lcyhvcHRzOiBPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IHRoaXMuZ2V0TWV0YWRhdGEob3B0cylcbiAgICByZXR1cm4gbWV0YWRhdGEucmVmSWRUb05hbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbWV0YWRhdGEgbWV0YWRhdGEgb2JqZWN0IGZyb20gdGhlIHBhcnNlZCBpbmRleCxcbiAgICogY29udGFpbmluZyBjb2x1bW5OdW1iZXJzLCBtZXRhQ2hhciwgYW5kIGZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaW9uUmVmTmFtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVnaW9uU3RhcnQgcmVnaW9uIHN0YXJ0IGNvb3JkaW5hdGUgKDAtYmFzZWQtaGFsZi1vcGVuKVxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVnaW9uRW5kIHJlZ2lvbiBlbmQgY29vcmRpbmF0ZSAoMC1iYXNlZC1oYWxmLW9wZW4pXG4gICAqIEBwYXJhbSB7YXJyYXlbc3RyaW5nXX0gbGluZVxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBsaWtlIGB7c3RhcnRDb29yZGluYXRlLCBvdmVybGFwc31gLiBvdmVybGFwcyBpcyBib29sZWFuLFxuICAgKiB0cnVlIGlmIGxpbmUgaXMgYSBkYXRhIGxpbmUgdGhhdCBvdmVybGFwcyB0aGUgZ2l2ZW4gcmVnaW9uXG4gICAqL1xuICBjaGVja0xpbmUoXG4gICAge1xuICAgICAgY29sdW1uTnVtYmVycyxcbiAgICAgIG1ldGFDaGFyLFxuICAgICAgY29vcmRpbmF0ZVR5cGUsXG4gICAgICBmb3JtYXQsXG4gICAgfToge1xuICAgICAgY29sdW1uTnVtYmVyczogeyByZWY6IG51bWJlcjsgc3RhcnQ6IG51bWJlcjsgZW5kOiBudW1iZXIgfVxuICAgICAgbWV0YUNoYXI6IHN0cmluZ1xuICAgICAgY29vcmRpbmF0ZVR5cGU6IHN0cmluZ1xuICAgICAgZm9ybWF0OiBzdHJpbmdcbiAgICB9LFxuICAgIHJlZ2lvblJlZk5hbWU6IHN0cmluZyxcbiAgICByZWdpb25TdGFydDogbnVtYmVyLFxuICAgIHJlZ2lvbkVuZDogbnVtYmVyLFxuICAgIGxpbmU6IHN0cmluZyxcbiAgKSB7XG4gICAgLy8gc2tpcCBtZXRhIGxpbmVzXG4gICAgaWYgKGxpbmUuY2hhckF0KDApID09PSBtZXRhQ2hhcikge1xuICAgICAgcmV0dXJuIHsgb3ZlcmxhcHM6IGZhbHNlIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayByZWYvc3RhcnQvZW5kIHVzaW5nIGNvbHVtbiBtZXRhZGF0YSBmcm9tIGluZGV4XG4gICAgbGV0IHsgcmVmLCBzdGFydCwgZW5kIH0gPSBjb2x1bW5OdW1iZXJzXG4gICAgaWYgKCFyZWYpIHJlZiA9IDBcbiAgICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgICBpZiAoIWVuZCkgZW5kID0gMFxuICAgIGlmIChmb3JtYXQgPT09ICdWQ0YnKSBlbmQgPSA4XG4gICAgY29uc3QgbWF4Q29sdW1uID0gTWF0aC5tYXgocmVmLCBzdGFydCwgZW5kKVxuXG4gICAgLy8gdGhpcyBjb2RlIGlzIGtpbmQgb2YgY29tcGxleCwgYnV0IGl0IGlzIGZhaXJseSBmYXN0LlxuICAgIC8vIGJhc2ljYWxseSwgd2Ugd2FudCB0byBhdm9pZCBkb2luZyBhIHNwbGl0LCBiZWNhdXNlIGlmIHRoZSBsaW5lcyBhcmUgcmVhbGx5IGxvbmdcbiAgICAvLyB0aGF0IGNvdWxkIGxlYWQgdG8gdXMgYWxsb2NhdGluZyBhIGJ1bmNoIG9mIGV4dHJhIG1lbW9yeSwgd2hpY2ggaXMgc2xvd1xuXG4gICAgbGV0IGN1cnJlbnRDb2x1bW5OdW1iZXIgPSAxIC8vIGNvbHMgYXJlIG51bWJlcmVkIHN0YXJ0aW5nIGF0IDEgaW4gdGhlIGluZGV4IG1ldGFkYXRhXG4gICAgbGV0IGN1cnJlbnRDb2x1bW5TdGFydCA9IDBcbiAgICBsZXQgcmVmU2VxID0gJydcbiAgICBsZXQgc3RhcnRDb29yZGluYXRlID0gLUluZmluaXR5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCArIDE7IGkgKz0gMSkge1xuICAgICAgaWYgKGxpbmVbaV0gPT09ICdcXHQnIHx8IGkgPT09IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q29sdW1uTnVtYmVyID09PSByZWYpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLnJlbmFtZVJlZlNlcShsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSkpICE9PVxuICAgICAgICAgICAgcmVnaW9uUmVmTmFtZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxhcHM6IGZhbHNlIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gc3RhcnQpIHtcbiAgICAgICAgICBzdGFydENvb3JkaW5hdGUgPSBwYXJzZUludChsaW5lLnNsaWNlKGN1cnJlbnRDb2x1bW5TdGFydCwgaSksIDEwKVxuICAgICAgICAgIC8vIHdlIGNvbnZlcnQgdG8gMC1iYXNlZC1oYWxmLW9wZW5cbiAgICAgICAgICBpZiAoY29vcmRpbmF0ZVR5cGUgPT09ICcxLWJhc2VkLWNsb3NlZCcpIHtcbiAgICAgICAgICAgIHN0YXJ0Q29vcmRpbmF0ZSAtPSAxXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydENvb3JkaW5hdGUgPj0gcmVnaW9uRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydENvb3JkaW5hdGUsIG92ZXJsYXBzOiBmYWxzZSB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmQgPT09IDAgfHwgZW5kID09PSBzdGFydCkge1xuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBubyBlbmQsIHdlIGFzc3VtZSB0aGUgZmVhdHVyZSBpcyAxIGJwIGxvbmdcbiAgICAgICAgICAgIGlmIChzdGFydENvb3JkaW5hdGUgKyAxIDw9IHJlZ2lvblN0YXJ0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHM6IGZhbHNlIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnVkNGJyAmJiBjdXJyZW50Q29sdW1uTnVtYmVyID09PSA0KSB7XG4gICAgICAgICAgcmVmU2VxID0gbGluZS5zbGljZShjdXJyZW50Q29sdW1uU3RhcnQsIGkpXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gZW5kKSB7XG4gICAgICAgICAgbGV0IGVuZENvb3JkaW5hdGVcbiAgICAgICAgICAvLyB0aGlzIHdpbGwgbmV2ZXIgbWF0Y2ggaWYgdGhlcmUgaXMgbm8gZW5kIGNvbHVtblxuICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdWQ0YnKSB7XG4gICAgICAgICAgICBlbmRDb29yZGluYXRlID0gdGhpcy5fZ2V0VmNmRW5kKFxuICAgICAgICAgICAgICBzdGFydENvb3JkaW5hdGUsXG4gICAgICAgICAgICAgIHJlZlNlcSxcbiAgICAgICAgICAgICAgbGluZS5zbGljZShjdXJyZW50Q29sdW1uU3RhcnQsIGkpLFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmRDb29yZGluYXRlID0gcGFyc2VJbnQobGluZS5zbGljZShjdXJyZW50Q29sdW1uU3RhcnQsIGkpLCAxMClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVuZENvb3JkaW5hdGUgPD0gcmVnaW9uU3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXBzOiBmYWxzZSB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRDb2x1bW5TdGFydCA9IGkgKyAxXG4gICAgICAgIGN1cnJlbnRDb2x1bW5OdW1iZXIgKz0gMVxuICAgICAgICBpZiAoY3VycmVudENvbHVtbk51bWJlciA+IG1heENvbHVtbikge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwczogdHJ1ZSB9XG4gIH1cblxuICBfZ2V0VmNmRW5kKHN0YXJ0Q29vcmRpbmF0ZTogbnVtYmVyLCByZWZTZXE6IHN0cmluZywgaW5mbzogYW55KSB7XG4gICAgbGV0IGVuZENvb3JkaW5hdGUgPSBzdGFydENvb3JkaW5hdGUgKyByZWZTZXEubGVuZ3RoXG4gICAgLy8gaWdub3JlIFRSQSBmZWF0dXJlcyBhcyB0aGV5IHNwZWNpZnkgQ0hSMiBhbmQgRU5EXG4gICAgLy8gYXMgYmVpbmcgb24gYSBkaWZmZXJlbnQgY2hyb21vc29tZVxuICAgIC8vIGlmIENIUjIgaXMgb24gdGhlIHNhbWUgY2hyb21vc29tZSwgc3RpbGwgaWdub3JlIGl0XG4gICAgLy8gYmVjYXVzZSB0aGVyZSBzaG91bGQgYmUgYW5vdGhlciBwYWlyd2lzZSBmZWF0dXJlXG4gICAgLy8gYXQgdGhlIGVuZCBvZiB0aGlzIG9uZVxuICAgIGNvbnN0IGlzVFJBID0gaW5mby5pbmRleE9mKCdTVlRZUEU9VFJBJykgIT09IC0xXG4gICAgaWYgKGluZm9bMF0gIT09ICcuJyAmJiAhaXNUUkEpIHtcbiAgICAgIGxldCBwcmV2Q2hhciA9ICc7J1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGlmIChwcmV2Q2hhciA9PT0gJzsnICYmIGluZm8uc2xpY2UoaiwgaiArIDQpID09PSAnRU5EPScpIHtcbiAgICAgICAgICBsZXQgdmFsdWVFbmQgPSBpbmZvLmluZGV4T2YoJzsnLCBqKVxuICAgICAgICAgIGlmICh2YWx1ZUVuZCA9PT0gLTEpIHZhbHVlRW5kID0gaW5mby5sZW5ndGhcbiAgICAgICAgICBlbmRDb29yZGluYXRlID0gcGFyc2VJbnQoaW5mby5zbGljZShqICsgNCwgdmFsdWVFbmQpLCAxMClcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHByZXZDaGFyID0gaW5mb1tqXVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUUkEpIHtcbiAgICAgIHJldHVybiBzdGFydENvb3JkaW5hdGUgKyAxXG4gICAgfVxuICAgIHJldHVybiBlbmRDb29yZGluYXRlXG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIHRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgZGF0YSBsaW5lcyBpbiB0aGUgZ2l2ZW4gcmVmZXJlbmNlIHNlcXVlbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWZTZXEgcmVmZXJlbmNlIHNlcXVlbmNlIG5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2V9IGZvciBudW1iZXIgb2YgZGF0YSBsaW5lcyBwcmVzZW50IG9uIHRoYXQgcmVmZXJlbmNlIHNlcXVlbmNlXG4gICAqL1xuICBhc3luYyBsaW5lQ291bnQocmVmTmFtZTogc3RyaW5nLCBvcHRzOiBPcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleC5saW5lQ291bnQocmVmTmFtZSwgb3B0cylcbiAgfVxuXG4gIGFzeW5jIF9yZWFkUmVnaW9uKFxuICAgIHBvc2l0aW9uOiBudW1iZXIsXG4gICAgY29tcHJlc3NlZFNpemU6IG51bWJlcixcbiAgICBvcHRzOiBPcHRpb25zID0ge30sXG4gICkge1xuICAgIGNvbnN0IHsgYnl0ZXNSZWFkLCBidWZmZXIgfSA9IGF3YWl0IHRoaXMuZmlsZWhhbmRsZS5yZWFkKFxuICAgICAgQnVmZmVyLmFsbG9jKGNvbXByZXNzZWRTaXplKSxcbiAgICAgIDAsXG4gICAgICBjb21wcmVzc2VkU2l6ZSxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgb3B0cyxcbiAgICApXG5cbiAgICByZXR1cm4gYnl0ZXNSZWFkIDwgY29tcHJlc3NlZFNpemUgPyBidWZmZXIuc2xpY2UoMCwgYnl0ZXNSZWFkKSA6IGJ1ZmZlclxuICB9XG5cbiAgLyoqXG4gICAqIHJlYWQgYW5kIHVuY29tcHJlc3MgdGhlIGRhdGEgaW4gYSBjaHVuayAoY29tcG9zZWQgb2Ygb25lIG9yIG1vcmVcbiAgICogY29udGlndW91cyBiZ3ppcCBibG9ja3MpIG9mIHRoZSBmaWxlXG4gICAqIEBwYXJhbSB7Q2h1bmt9IGNodW5rXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3IgYSBzdHJpbmcgY2h1bmsgb2YgdGhlIGZpbGVcbiAgICovXG4gIGFzeW5jIHJlYWRDaHVuayhjaHVuazogQ2h1bmssIG9wdHM6IE9wdGlvbnMgPSB7fSkge1xuICAgIC8vIGZldGNoIHRoZSB1bmNvbXByZXNzZWQgZGF0YSwgdW5jb21wcmVzcyBjYXJlZnVsbHkgYSBibG9jayBhdCBhIHRpbWUsXG4gICAgLy8gYW5kIHN0b3Agd2hlbiBkb25lXG5cbiAgICBjb25zdCBjb21wcmVzc2VkRGF0YSA9IGF3YWl0IHRoaXMuX3JlYWRSZWdpb24oXG4gICAgICBjaHVuay5taW52LmJsb2NrUG9zaXRpb24sXG4gICAgICBjaHVuay5mZXRjaGVkU2l6ZSgpLFxuICAgICAgb3B0cyxcbiAgICApXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB1bnppcENodW5rU2xpY2UoY29tcHJlc3NlZERhdGEsIGNodW5rKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZXJyb3IgZGVjb21wcmVzc2luZyBjaHVuayAke2NodW5rLnRvU3RyaW5nKCl9ICR7ZX1gKVxuICAgIH1cbiAgfVxufVxuIl19